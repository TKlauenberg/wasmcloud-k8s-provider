// Generated by `wit-bindgen-wrpc-go` 0.11.0. DO NOT EDIT!
package request

import (
	bytes "bytes"
	context "context"
	errors "errors"
	fmt "fmt"
	k8s__provider__types "github.com/TKlauenberg/wasmcloud-k8s-provider/bindings/k8s/provider/types"
	io "io"
	slog "log/slog"
	utf8 "unicode/utf8"
	wrpc "wrpc.io/go"
)

type KubernetesResource = k8s__provider__types.KubernetesResource
type Error = k8s__provider__types.Error

// Get information about a Kubernetes resource.
// @param resource The resource to get information about.
// @returns The resource information.
func Get(ctx__ context.Context, wrpc__ wrpc.Invoker, k8sResource *k8s__provider__types.KubernetesResource) (r0__ *wrpc.Result[KubernetesResource, Error], err__ error) {
	var buf__ bytes.Buffer
	write0__, err__ := (k8sResource).WriteToIndex(&buf__)
	if err__ != nil {
		err__ = fmt.Errorf("failed to write `k8s-resource` parameter: %w", err__)
		return
	}
	if write0__ != nil {
		err__ = errors.New("unexpected deferred write for synchronous `k8s-resource` parameter")
		return
	}
	var w__ wrpc.IndexWriteCloser
	var r__ wrpc.IndexReadCloser
	w__, r__, err__ = wrpc__.Invoke(ctx__, "k8s:provider/request@0.1.0", "get", buf__.Bytes())
	if err__ != nil {
		err__ = fmt.Errorf("failed to invoke `get`: %w", err__)
		return
	}
	defer func() {
		if err := r__.Close(); err != nil {
			slog.ErrorContext(ctx__, "failed to close reader", "instance", "k8s:provider/request@0.1.0", "name", "get", "err", err)
		}
	}()
	if cErr__ := w__.Close(); cErr__ != nil {
		slog.DebugContext(ctx__, "failed to close outgoing stream", "instance", "k8s:provider/request@0.1.0", "name", "get", "err", cErr__)
	}
	r0__, err__ = func(r wrpc.IndexReadCloser, path ...uint32) (*wrpc.Result[KubernetesResource, Error], error) {
		slog.Debug("reading result status byte")
		status, err := r.ReadByte()
		if err != nil {
			return nil, fmt.Errorf("failed to read result status byte: %w", err)
		}
		switch status {
		case 0:
			slog.Debug("reading `result::ok` payload")
			v, err := func() (*KubernetesResource, error) {
				v, err := func(r wrpc.IndexReadCloser, path ...uint32) (*k8s__provider__types.KubernetesResource, error) {
					v := &k8s__provider__types.KubernetesResource{}
					var err error
					slog.Debug("reading field", "name", "api-version")
					v.ApiVersion, err = func(r interface {
						io.ByteReader
						io.Reader
					}) (string, error) { var x uint32; var s uint8; for i := 0; i < 5; i++ {
						slog.Debug("reading string length byte", "i", i)
						b, err := r.ReadByte()
						if err != nil {
							if i > 0 && err == io.EOF {
								err = io.ErrUnexpectedEOF
							}
							return "", fmt.Errorf("failed to read string length byte: %w", err)
						}
						if s == 28 && b > 0x0f {
							return "", errors.New("string length overflows a 32-bit integer")
						}
						if b < 0x80 {
							x = x | uint32(b)<<s
							if x == 0 {
								return "", nil
							}
							buf := make([]byte, x)
							slog.Debug("reading string bytes", "len", x)
							_, err = r.Read(buf)
							if err != nil {
								return "", fmt.Errorf("failed to read string bytes: %w", err)
							}
							if !utf8.Valid(buf) {
								return string(buf), errors.New("string is not valid UTF-8")
							}
							return string(buf), nil
						}
						x |= uint32(b&0x7f) << s
						s += 7
					}; return "", errors.New("string length overflows a 32-bit integer") }(r)
					if err != nil {
						return nil, fmt.Errorf("failed to read `api-version` field: %w", err)
					}
					slog.Debug("reading field", "name", "kind")
					v.Kind, err = func(r interface {
						io.ByteReader
						io.Reader
					}) (string, error) {
						var x uint32
						var s uint8
						for i := 0; i < 5; i++ {
							slog.Debug("reading string length byte", "i", i)
							b, err := r.ReadByte()
							if err != nil {
								if i > 0 && err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								return "", fmt.Errorf("failed to read string length byte: %w", err)
							}
							if s == 28 && b > 0x0f {
								return "", errors.New("string length overflows a 32-bit integer")
							}
							if b < 0x80 {
								x = x | uint32(b)<<s
								if x == 0 {
									return "", nil
								}
								buf := make([]byte, x)
								slog.Debug("reading string bytes", "len", x)
								_, err = r.Read(buf)
								if err != nil {
									return "", fmt.Errorf("failed to read string bytes: %w", err)
								}
								if !utf8.Valid(buf) {
									return string(buf), errors.New("string is not valid UTF-8")
								}
								return string(buf), nil
							}
							x |= uint32(b&0x7f) << s
							s += 7
						}
						return "", errors.New("string length overflows a 32-bit integer")
					}(r)
					if err != nil {
						return nil, fmt.Errorf("failed to read `kind` field: %w", err)
					}
					slog.Debug("reading field", "name", "metadata")
					v.Metadata, err = func(r wrpc.IndexReadCloser, path ...uint32) (*k8s__provider__types.Metadata, error) {
						v := &k8s__provider__types.Metadata{}
						var err error
						slog.Debug("reading field", "name", "name")
						v.Name, err = func(r interface {
							io.ByteReader
							io.Reader
						}) (string, error) {
							var x uint32
							var s uint8
							for i := 0; i < 5; i++ {
								slog.Debug("reading string length byte", "i", i)
								b, err := r.ReadByte()
								if err != nil {
									if i > 0 && err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									return "", fmt.Errorf("failed to read string length byte: %w", err)
								}
								if s == 28 && b > 0x0f {
									return "", errors.New("string length overflows a 32-bit integer")
								}
								if b < 0x80 {
									x = x | uint32(b)<<s
									if x == 0 {
										return "", nil
									}
									buf := make([]byte, x)
									slog.Debug("reading string bytes", "len", x)
									_, err = r.Read(buf)
									if err != nil {
										return "", fmt.Errorf("failed to read string bytes: %w", err)
									}
									if !utf8.Valid(buf) {
										return string(buf), errors.New("string is not valid UTF-8")
									}
									return string(buf), nil
								}
								x |= uint32(b&0x7f) << s
								s += 7
							}
							return "", errors.New("string length overflows a 32-bit integer")
						}(r)
						if err != nil {
							return nil, fmt.Errorf("failed to read `name` field: %w", err)
						}
						slog.Debug("reading field", "name", "namespace")
						v.Namespace, err = func(r interface {
							io.ByteReader
							io.Reader
						}) (string, error) { var x uint32; var s uint8; for i := 0; i < 5; i++ {
							slog.Debug("reading string length byte", "i", i)
							b, err := r.ReadByte()
							if err != nil {
								if i > 0 && err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								return "", fmt.Errorf("failed to read string length byte: %w", err)
							}
							if s == 28 && b > 0x0f {
								return "", errors.New("string length overflows a 32-bit integer")
							}
							if b < 0x80 {
								x = x | uint32(b)<<s
								if x == 0 {
									return "", nil
								}
								buf := make([]byte, x)
								slog.Debug("reading string bytes", "len", x)
								_, err = r.Read(buf)
								if err != nil {
									return "", fmt.Errorf("failed to read string bytes: %w", err)
								}
								if !utf8.Valid(buf) {
									return string(buf), errors.New("string is not valid UTF-8")
								}
								return string(buf), nil
							}
							x |= uint32(b&0x7f) << s
							s += 7
						}; return "", errors.New("string length overflows a 32-bit integer") }(r)
						if err != nil {
							return nil, fmt.Errorf("failed to read `namespace` field: %w", err)
						}
						slog.Debug("reading field", "name", "labels")
						v.Labels, err = func(r wrpc.IndexReadCloser, path ...uint32) ([]*wrpc.Tuple2[string, string], error) {
							var x uint32
							var s uint
							for i := 0; i < 5; i++ {
								slog.Debug("reading list length byte", "i", i)
								b, err := r.ReadByte()
								if err != nil {
									if i > 0 && err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									return nil, fmt.Errorf("failed to read list length byte: %w", err)
								}
								if s == 28 && b > 0x0f {
									return nil, errors.New("list length overflows a 32-bit integer")
								}
								if b < 0x80 {
									x = x | uint32(b)<<s
									if x == 0 {
										return nil, nil
									}
									vs := make([]*wrpc.Tuple2[string, string], x)
									for i := range vs {
										slog.Debug("reading list element", "i", i)
										vs[i], err = func(r wrpc.IndexReadCloser, path ...uint32) (*wrpc.Tuple2[string, string], error) {
											v := &wrpc.Tuple2[string, string]{}
											var err error
											slog.Debug("reading tuple element 0")
											v.V0, err = func(r interface {
												io.ByteReader
												io.Reader
											}) (string, error) {
												var x uint32
												var s uint8
												for i := 0; i < 5; i++ {
													slog.Debug("reading string length byte", "i", i)
													b, err := r.ReadByte()
													if err != nil {
														if i > 0 && err == io.EOF {
															err = io.ErrUnexpectedEOF
														}
														return "", fmt.Errorf("failed to read string length byte: %w", err)
													}
													if s == 28 && b > 0x0f {
														return "", errors.New("string length overflows a 32-bit integer")
													}
													if b < 0x80 {
														x = x | uint32(b)<<s
														if x == 0 {
															return "", nil
														}
														buf := make([]byte, x)
														slog.Debug("reading string bytes", "len", x)
														_, err = r.Read(buf)
														if err != nil {
															return "", fmt.Errorf("failed to read string bytes: %w", err)
														}
														if !utf8.Valid(buf) {
															return string(buf), errors.New("string is not valid UTF-8")
														}
														return string(buf), nil
													}
													x |= uint32(b&0x7f) << s
													s += 7
												}
												return "", errors.New("string length overflows a 32-bit integer")
											}(r)
											if err != nil {
												return nil, fmt.Errorf("failed to read tuple element 0: %w", err)
											}
											slog.Debug("reading tuple element 1")
											v.V1, err = func(r interface {
												io.ByteReader
												io.Reader
											}) (string, error) {
												var x uint32
												var s uint8
												for i := 0; i < 5; i++ {
													slog.Debug("reading string length byte", "i", i)
													b, err := r.ReadByte()
													if err != nil {
														if i > 0 && err == io.EOF {
															err = io.ErrUnexpectedEOF
														}
														return "", fmt.Errorf("failed to read string length byte: %w", err)
													}
													if s == 28 && b > 0x0f {
														return "", errors.New("string length overflows a 32-bit integer")
													}
													if b < 0x80 {
														x = x | uint32(b)<<s
														if x == 0 {
															return "", nil
														}
														buf := make([]byte, x)
														slog.Debug("reading string bytes", "len", x)
														_, err = r.Read(buf)
														if err != nil {
															return "", fmt.Errorf("failed to read string bytes: %w", err)
														}
														if !utf8.Valid(buf) {
															return string(buf), errors.New("string is not valid UTF-8")
														}
														return string(buf), nil
													}
													x |= uint32(b&0x7f) << s
													s += 7
												}
												return "", errors.New("string length overflows a 32-bit integer")
											}(r)
											if err != nil {
												return nil, fmt.Errorf("failed to read tuple element 1: %w", err)
											}
											return v, nil
										}(r, append(path, uint32(i))...)
										if err != nil {
											return nil, fmt.Errorf("failed to read list element %d: %w", i, err)
										}
									}
									return vs, nil
								}
								x |= uint32(b&0x7f) << s
								s += 7
							}
							return nil, errors.New("list length overflows a 32-bit integer")
						}(r, append(path, 2)...)
						if err != nil {
							return nil, fmt.Errorf("failed to read `labels` field: %w", err)
						}
						slog.Debug("reading field", "name", "annotations")
						v.Annotations, err = func(r wrpc.IndexReadCloser, path ...uint32) ([]*wrpc.Tuple2[string, string], error) {
							var x uint32
							var s uint
							for i := 0; i < 5; i++ {
								slog.Debug("reading list length byte", "i", i)
								b, err := r.ReadByte()
								if err != nil {
									if i > 0 && err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									return nil, fmt.Errorf("failed to read list length byte: %w", err)
								}
								if s == 28 && b > 0x0f {
									return nil, errors.New("list length overflows a 32-bit integer")
								}
								if b < 0x80 {
									x = x | uint32(b)<<s
									if x == 0 {
										return nil, nil
									}
									vs := make([]*wrpc.Tuple2[string, string], x)
									for i := range vs {
										slog.Debug("reading list element", "i", i)
										vs[i], err = func(r wrpc.IndexReadCloser, path ...uint32) (*wrpc.Tuple2[string, string], error) {
											v := &wrpc.Tuple2[string, string]{}
											var err error
											slog.Debug("reading tuple element 0")
											v.V0, err = func(r interface {
												io.ByteReader
												io.Reader
											}) (string, error) {
												var x uint32
												var s uint8
												for i := 0; i < 5; i++ {
													slog.Debug("reading string length byte", "i", i)
													b, err := r.ReadByte()
													if err != nil {
														if i > 0 && err == io.EOF {
															err = io.ErrUnexpectedEOF
														}
														return "", fmt.Errorf("failed to read string length byte: %w", err)
													}
													if s == 28 && b > 0x0f {
														return "", errors.New("string length overflows a 32-bit integer")
													}
													if b < 0x80 {
														x = x | uint32(b)<<s
														if x == 0 {
															return "", nil
														}
														buf := make([]byte, x)
														slog.Debug("reading string bytes", "len", x)
														_, err = r.Read(buf)
														if err != nil {
															return "", fmt.Errorf("failed to read string bytes: %w", err)
														}
														if !utf8.Valid(buf) {
															return string(buf), errors.New("string is not valid UTF-8")
														}
														return string(buf), nil
													}
													x |= uint32(b&0x7f) << s
													s += 7
												}
												return "", errors.New("string length overflows a 32-bit integer")
											}(r)
											if err != nil {
												return nil, fmt.Errorf("failed to read tuple element 0: %w", err)
											}
											slog.Debug("reading tuple element 1")
											v.V1, err = func(r interface {
												io.ByteReader
												io.Reader
											}) (string, error) {
												var x uint32
												var s uint8
												for i := 0; i < 5; i++ {
													slog.Debug("reading string length byte", "i", i)
													b, err := r.ReadByte()
													if err != nil {
														if i > 0 && err == io.EOF {
															err = io.ErrUnexpectedEOF
														}
														return "", fmt.Errorf("failed to read string length byte: %w", err)
													}
													if s == 28 && b > 0x0f {
														return "", errors.New("string length overflows a 32-bit integer")
													}
													if b < 0x80 {
														x = x | uint32(b)<<s
														if x == 0 {
															return "", nil
														}
														buf := make([]byte, x)
														slog.Debug("reading string bytes", "len", x)
														_, err = r.Read(buf)
														if err != nil {
															return "", fmt.Errorf("failed to read string bytes: %w", err)
														}
														if !utf8.Valid(buf) {
															return string(buf), errors.New("string is not valid UTF-8")
														}
														return string(buf), nil
													}
													x |= uint32(b&0x7f) << s
													s += 7
												}
												return "", errors.New("string length overflows a 32-bit integer")
											}(r)
											if err != nil {
												return nil, fmt.Errorf("failed to read tuple element 1: %w", err)
											}
											return v, nil
										}(r, append(path, uint32(i))...)
										if err != nil {
											return nil, fmt.Errorf("failed to read list element %d: %w", i, err)
										}
									}
									return vs, nil
								}
								x |= uint32(b&0x7f) << s
								s += 7
							}
							return nil, errors.New("list length overflows a 32-bit integer")
						}(r, append(path, 3)...)
						if err != nil {
							return nil, fmt.Errorf("failed to read `annotations` field: %w", err)
						}
						return v, nil
					}(r, append(path, 2)...)
					if err != nil {
						return nil, fmt.Errorf("failed to read `metadata` field: %w", err)
					}
					slog.Debug("reading field", "name", "spec")
					v.Spec, err = func(r interface {
						io.ByteReader
						io.Reader
					}) (string, error) {
						var x uint32
						var s uint8
						for i := 0; i < 5; i++ {
							slog.Debug("reading string length byte", "i", i)
							b, err := r.ReadByte()
							if err != nil {
								if i > 0 && err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								return "", fmt.Errorf("failed to read string length byte: %w", err)
							}
							if s == 28 && b > 0x0f {
								return "", errors.New("string length overflows a 32-bit integer")
							}
							if b < 0x80 {
								x = x | uint32(b)<<s
								if x == 0 {
									return "", nil
								}
								buf := make([]byte, x)
								slog.Debug("reading string bytes", "len", x)
								_, err = r.Read(buf)
								if err != nil {
									return "", fmt.Errorf("failed to read string bytes: %w", err)
								}
								if !utf8.Valid(buf) {
									return string(buf), errors.New("string is not valid UTF-8")
								}
								return string(buf), nil
							}
							x |= uint32(b&0x7f) << s
							s += 7
						}
						return "", errors.New("string length overflows a 32-bit integer")
					}(r)
					if err != nil {
						return nil, fmt.Errorf("failed to read `spec` field: %w", err)
					}
					return v, nil
				}(r, path...)
				return (*KubernetesResource)(v), err
			}()

			if err != nil {
				return nil, fmt.Errorf("failed to read `result::ok` value: %w", err)
			}
			return &wrpc.Result[KubernetesResource, Error]{Ok: v}, nil
		case 1:
			slog.Debug("reading `result::err` payload")
			v, err := func() (*Error, error) {
				v, err := func(r wrpc.IndexReadCloser, path ...uint32) (*k8s__provider__types.Error, error) {
					v := &k8s__provider__types.Error{}
					n, err := func(r io.ByteReader) (uint8, error) {
						var x uint8
						var s uint
						for i := 0; i < 2; i++ {
							slog.Debug("reading u8 discriminant byte", "i", i)
							b, err := r.ReadByte()
							if err != nil {
								if i > 0 && err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								return x, fmt.Errorf("failed to read u8 discriminant byte: %w", err)
							}
							if s == 7 && b > 0x01 {
								return x, errors.New("discriminant overflows an 8-bit integer")
							}
							if b < 0x80 {
								return x | uint8(b)<<s, nil
							}
							x |= uint8(b&0x7f) << s
							s += 7
						}
						return x, errors.New("discriminant overflows an 8-bit integer")
					}(r)
					if err != nil {
						return nil, fmt.Errorf("failed to read discriminant: %w", err)
					}
					switch k8s__provider__types.ErrorDiscriminant(n) {
					case k8s__provider__types.ErrorNotFound:
						payload, err := func(r interface {
							io.ByteReader
							io.Reader
						}) (string, error) {
							var x uint32
							var s uint8
							for i := 0; i < 5; i++ {
								slog.Debug("reading string length byte", "i", i)
								b, err := r.ReadByte()
								if err != nil {
									if i > 0 && err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									return "", fmt.Errorf("failed to read string length byte: %w", err)
								}
								if s == 28 && b > 0x0f {
									return "", errors.New("string length overflows a 32-bit integer")
								}
								if b < 0x80 {
									x = x | uint32(b)<<s
									if x == 0 {
										return "", nil
									}
									buf := make([]byte, x)
									slog.Debug("reading string bytes", "len", x)
									_, err = r.Read(buf)
									if err != nil {
										return "", fmt.Errorf("failed to read string bytes: %w", err)
									}
									if !utf8.Valid(buf) {
										return string(buf), errors.New("string is not valid UTF-8")
									}
									return string(buf), nil
								}
								x |= uint32(b&0x7f) << s
								s += 7
							}
							return "", errors.New("string length overflows a 32-bit integer")
						}(r)
						if err != nil {
							return nil, fmt.Errorf("failed to read `not-found` payload: %w", err)
						}
						return v.SetNotFound(payload), nil
					case k8s__provider__types.ErrorAlreadyExists:
						payload, err := func(r interface {
							io.ByteReader
							io.Reader
						}) (string, error) {
							var x uint32
							var s uint8
							for i := 0; i < 5; i++ {
								slog.Debug("reading string length byte", "i", i)
								b, err := r.ReadByte()
								if err != nil {
									if i > 0 && err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									return "", fmt.Errorf("failed to read string length byte: %w", err)
								}
								if s == 28 && b > 0x0f {
									return "", errors.New("string length overflows a 32-bit integer")
								}
								if b < 0x80 {
									x = x | uint32(b)<<s
									if x == 0 {
										return "", nil
									}
									buf := make([]byte, x)
									slog.Debug("reading string bytes", "len", x)
									_, err = r.Read(buf)
									if err != nil {
										return "", fmt.Errorf("failed to read string bytes: %w", err)
									}
									if !utf8.Valid(buf) {
										return string(buf), errors.New("string is not valid UTF-8")
									}
									return string(buf), nil
								}
								x |= uint32(b&0x7f) << s
								s += 7
							}
							return "", errors.New("string length overflows a 32-bit integer")
						}(r)
						if err != nil {
							return nil, fmt.Errorf("failed to read `already-exists` payload: %w", err)
						}
						return v.SetAlreadyExists(payload), nil
					case k8s__provider__types.ErrorInvalidInput:
						payload, err := func(r interface {
							io.ByteReader
							io.Reader
						}) (string, error) {
							var x uint32
							var s uint8
							for i := 0; i < 5; i++ {
								slog.Debug("reading string length byte", "i", i)
								b, err := r.ReadByte()
								if err != nil {
									if i > 0 && err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									return "", fmt.Errorf("failed to read string length byte: %w", err)
								}
								if s == 28 && b > 0x0f {
									return "", errors.New("string length overflows a 32-bit integer")
								}
								if b < 0x80 {
									x = x | uint32(b)<<s
									if x == 0 {
										return "", nil
									}
									buf := make([]byte, x)
									slog.Debug("reading string bytes", "len", x)
									_, err = r.Read(buf)
									if err != nil {
										return "", fmt.Errorf("failed to read string bytes: %w", err)
									}
									if !utf8.Valid(buf) {
										return string(buf), errors.New("string is not valid UTF-8")
									}
									return string(buf), nil
								}
								x |= uint32(b&0x7f) << s
								s += 7
							}
							return "", errors.New("string length overflows a 32-bit integer")
						}(r)
						if err != nil {
							return nil, fmt.Errorf("failed to read `invalid-input` payload: %w", err)
						}
						return v.SetInvalidInput(payload), nil
					case k8s__provider__types.ErrorPermissionDenied:
						payload, err := func(r interface {
							io.ByteReader
							io.Reader
						}) (string, error) {
							var x uint32
							var s uint8
							for i := 0; i < 5; i++ {
								slog.Debug("reading string length byte", "i", i)
								b, err := r.ReadByte()
								if err != nil {
									if i > 0 && err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									return "", fmt.Errorf("failed to read string length byte: %w", err)
								}
								if s == 28 && b > 0x0f {
									return "", errors.New("string length overflows a 32-bit integer")
								}
								if b < 0x80 {
									x = x | uint32(b)<<s
									if x == 0 {
										return "", nil
									}
									buf := make([]byte, x)
									slog.Debug("reading string bytes", "len", x)
									_, err = r.Read(buf)
									if err != nil {
										return "", fmt.Errorf("failed to read string bytes: %w", err)
									}
									if !utf8.Valid(buf) {
										return string(buf), errors.New("string is not valid UTF-8")
									}
									return string(buf), nil
								}
								x |= uint32(b&0x7f) << s
								s += 7
							}
							return "", errors.New("string length overflows a 32-bit integer")
						}(r)
						if err != nil {
							return nil, fmt.Errorf("failed to read `permission-denied` payload: %w", err)
						}
						return v.SetPermissionDenied(payload), nil
					case k8s__provider__types.ErrorUnknown:
						payload, err := func(r interface {
							io.ByteReader
							io.Reader
						}) (string, error) {
							var x uint32
							var s uint8
							for i := 0; i < 5; i++ {
								slog.Debug("reading string length byte", "i", i)
								b, err := r.ReadByte()
								if err != nil {
									if i > 0 && err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									return "", fmt.Errorf("failed to read string length byte: %w", err)
								}
								if s == 28 && b > 0x0f {
									return "", errors.New("string length overflows a 32-bit integer")
								}
								if b < 0x80 {
									x = x | uint32(b)<<s
									if x == 0 {
										return "", nil
									}
									buf := make([]byte, x)
									slog.Debug("reading string bytes", "len", x)
									_, err = r.Read(buf)
									if err != nil {
										return "", fmt.Errorf("failed to read string bytes: %w", err)
									}
									if !utf8.Valid(buf) {
										return string(buf), errors.New("string is not valid UTF-8")
									}
									return string(buf), nil
								}
								x |= uint32(b&0x7f) << s
								s += 7
							}
							return "", errors.New("string length overflows a 32-bit integer")
						}(r)
						if err != nil {
							return nil, fmt.Errorf("failed to read `unknown` payload: %w", err)
						}
						return v.SetUnknown(payload), nil
					default:
						return nil, fmt.Errorf("unknown discriminant value %d", n)
					}
				}(r, path...)
				return (*Error)(v), err
			}()

			if err != nil {
				return nil, fmt.Errorf("failed to read `result::err` value: %w", err)
			}
			return &wrpc.Result[KubernetesResource, Error]{Err: v}, nil
		default:
			return nil, fmt.Errorf("invalid result status byte %d", status)
		}
	}(r__, []uint32{0}...)
	if err__ != nil {
		err__ = fmt.Errorf("failed to read result 0: %w", err__)
		return
	}
	return
}

// Create a new Kubernetes resource.
// @param resource The resource to create.
// @returns The status of the creation operation.
func Create(ctx__ context.Context, wrpc__ wrpc.Invoker, k8sResource *k8s__provider__types.KubernetesResource) (r0__ *wrpc.Result[string, Error], err__ error) {
	var buf__ bytes.Buffer
	write0__, err__ := (k8sResource).WriteToIndex(&buf__)
	if err__ != nil {
		err__ = fmt.Errorf("failed to write `k8s-resource` parameter: %w", err__)
		return
	}
	if write0__ != nil {
		err__ = errors.New("unexpected deferred write for synchronous `k8s-resource` parameter")
		return
	}
	var w__ wrpc.IndexWriteCloser
	var r__ wrpc.IndexReadCloser
	w__, r__, err__ = wrpc__.Invoke(ctx__, "k8s:provider/request@0.1.0", "create", buf__.Bytes())
	if err__ != nil {
		err__ = fmt.Errorf("failed to invoke `create`: %w", err__)
		return
	}
	defer func() {
		if err := r__.Close(); err != nil {
			slog.ErrorContext(ctx__, "failed to close reader", "instance", "k8s:provider/request@0.1.0", "name", "create", "err", err)
		}
	}()
	if cErr__ := w__.Close(); cErr__ != nil {
		slog.DebugContext(ctx__, "failed to close outgoing stream", "instance", "k8s:provider/request@0.1.0", "name", "create", "err", cErr__)
	}
	r0__, err__ = func(r wrpc.IndexReadCloser, path ...uint32) (*wrpc.Result[string, Error], error) {
		slog.Debug("reading result status byte")
		status, err := r.ReadByte()
		if err != nil {
			return nil, fmt.Errorf("failed to read result status byte: %w", err)
		}
		switch status {
		case 0:
			slog.Debug("reading `result::ok` payload")
			v, err := func(r interface {
				io.ByteReader
				io.Reader
			}) (string, error) {
				var x uint32
				var s uint8
				for i := 0; i < 5; i++ {
					slog.Debug("reading string length byte", "i", i)
					b, err := r.ReadByte()
					if err != nil {
						if i > 0 && err == io.EOF {
							err = io.ErrUnexpectedEOF
						}
						return "", fmt.Errorf("failed to read string length byte: %w", err)
					}
					if s == 28 && b > 0x0f {
						return "", errors.New("string length overflows a 32-bit integer")
					}
					if b < 0x80 {
						x = x | uint32(b)<<s
						if x == 0 {
							return "", nil
						}
						buf := make([]byte, x)
						slog.Debug("reading string bytes", "len", x)
						_, err = r.Read(buf)
						if err != nil {
							return "", fmt.Errorf("failed to read string bytes: %w", err)
						}
						if !utf8.Valid(buf) {
							return string(buf), errors.New("string is not valid UTF-8")
						}
						return string(buf), nil
					}
					x |= uint32(b&0x7f) << s
					s += 7
				}
				return "", errors.New("string length overflows a 32-bit integer")
			}(r)
			if err != nil {
				return nil, fmt.Errorf("failed to read `result::ok` value: %w", err)
			}
			return &wrpc.Result[string, Error]{Ok: &v}, nil
		case 1:
			slog.Debug("reading `result::err` payload")
			v, err := func() (*Error, error) {
				v, err := func(r wrpc.IndexReadCloser, path ...uint32) (*k8s__provider__types.Error, error) {
					v := &k8s__provider__types.Error{}
					n, err := func(r io.ByteReader) (uint8, error) {
						var x uint8
						var s uint
						for i := 0; i < 2; i++ {
							slog.Debug("reading u8 discriminant byte", "i", i)
							b, err := r.ReadByte()
							if err != nil {
								if i > 0 && err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								return x, fmt.Errorf("failed to read u8 discriminant byte: %w", err)
							}
							if s == 7 && b > 0x01 {
								return x, errors.New("discriminant overflows an 8-bit integer")
							}
							if b < 0x80 {
								return x | uint8(b)<<s, nil
							}
							x |= uint8(b&0x7f) << s
							s += 7
						}
						return x, errors.New("discriminant overflows an 8-bit integer")
					}(r)
					if err != nil {
						return nil, fmt.Errorf("failed to read discriminant: %w", err)
					}
					switch k8s__provider__types.ErrorDiscriminant(n) {
					case k8s__provider__types.ErrorNotFound:
						payload, err := func(r interface {
							io.ByteReader
							io.Reader
						}) (string, error) {
							var x uint32
							var s uint8
							for i := 0; i < 5; i++ {
								slog.Debug("reading string length byte", "i", i)
								b, err := r.ReadByte()
								if err != nil {
									if i > 0 && err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									return "", fmt.Errorf("failed to read string length byte: %w", err)
								}
								if s == 28 && b > 0x0f {
									return "", errors.New("string length overflows a 32-bit integer")
								}
								if b < 0x80 {
									x = x | uint32(b)<<s
									if x == 0 {
										return "", nil
									}
									buf := make([]byte, x)
									slog.Debug("reading string bytes", "len", x)
									_, err = r.Read(buf)
									if err != nil {
										return "", fmt.Errorf("failed to read string bytes: %w", err)
									}
									if !utf8.Valid(buf) {
										return string(buf), errors.New("string is not valid UTF-8")
									}
									return string(buf), nil
								}
								x |= uint32(b&0x7f) << s
								s += 7
							}
							return "", errors.New("string length overflows a 32-bit integer")
						}(r)
						if err != nil {
							return nil, fmt.Errorf("failed to read `not-found` payload: %w", err)
						}
						return v.SetNotFound(payload), nil
					case k8s__provider__types.ErrorAlreadyExists:
						payload, err := func(r interface {
							io.ByteReader
							io.Reader
						}) (string, error) {
							var x uint32
							var s uint8
							for i := 0; i < 5; i++ {
								slog.Debug("reading string length byte", "i", i)
								b, err := r.ReadByte()
								if err != nil {
									if i > 0 && err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									return "", fmt.Errorf("failed to read string length byte: %w", err)
								}
								if s == 28 && b > 0x0f {
									return "", errors.New("string length overflows a 32-bit integer")
								}
								if b < 0x80 {
									x = x | uint32(b)<<s
									if x == 0 {
										return "", nil
									}
									buf := make([]byte, x)
									slog.Debug("reading string bytes", "len", x)
									_, err = r.Read(buf)
									if err != nil {
										return "", fmt.Errorf("failed to read string bytes: %w", err)
									}
									if !utf8.Valid(buf) {
										return string(buf), errors.New("string is not valid UTF-8")
									}
									return string(buf), nil
								}
								x |= uint32(b&0x7f) << s
								s += 7
							}
							return "", errors.New("string length overflows a 32-bit integer")
						}(r)
						if err != nil {
							return nil, fmt.Errorf("failed to read `already-exists` payload: %w", err)
						}
						return v.SetAlreadyExists(payload), nil
					case k8s__provider__types.ErrorInvalidInput:
						payload, err := func(r interface {
							io.ByteReader
							io.Reader
						}) (string, error) {
							var x uint32
							var s uint8
							for i := 0; i < 5; i++ {
								slog.Debug("reading string length byte", "i", i)
								b, err := r.ReadByte()
								if err != nil {
									if i > 0 && err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									return "", fmt.Errorf("failed to read string length byte: %w", err)
								}
								if s == 28 && b > 0x0f {
									return "", errors.New("string length overflows a 32-bit integer")
								}
								if b < 0x80 {
									x = x | uint32(b)<<s
									if x == 0 {
										return "", nil
									}
									buf := make([]byte, x)
									slog.Debug("reading string bytes", "len", x)
									_, err = r.Read(buf)
									if err != nil {
										return "", fmt.Errorf("failed to read string bytes: %w", err)
									}
									if !utf8.Valid(buf) {
										return string(buf), errors.New("string is not valid UTF-8")
									}
									return string(buf), nil
								}
								x |= uint32(b&0x7f) << s
								s += 7
							}
							return "", errors.New("string length overflows a 32-bit integer")
						}(r)
						if err != nil {
							return nil, fmt.Errorf("failed to read `invalid-input` payload: %w", err)
						}
						return v.SetInvalidInput(payload), nil
					case k8s__provider__types.ErrorPermissionDenied:
						payload, err := func(r interface {
							io.ByteReader
							io.Reader
						}) (string, error) {
							var x uint32
							var s uint8
							for i := 0; i < 5; i++ {
								slog.Debug("reading string length byte", "i", i)
								b, err := r.ReadByte()
								if err != nil {
									if i > 0 && err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									return "", fmt.Errorf("failed to read string length byte: %w", err)
								}
								if s == 28 && b > 0x0f {
									return "", errors.New("string length overflows a 32-bit integer")
								}
								if b < 0x80 {
									x = x | uint32(b)<<s
									if x == 0 {
										return "", nil
									}
									buf := make([]byte, x)
									slog.Debug("reading string bytes", "len", x)
									_, err = r.Read(buf)
									if err != nil {
										return "", fmt.Errorf("failed to read string bytes: %w", err)
									}
									if !utf8.Valid(buf) {
										return string(buf), errors.New("string is not valid UTF-8")
									}
									return string(buf), nil
								}
								x |= uint32(b&0x7f) << s
								s += 7
							}
							return "", errors.New("string length overflows a 32-bit integer")
						}(r)
						if err != nil {
							return nil, fmt.Errorf("failed to read `permission-denied` payload: %w", err)
						}
						return v.SetPermissionDenied(payload), nil
					case k8s__provider__types.ErrorUnknown:
						payload, err := func(r interface {
							io.ByteReader
							io.Reader
						}) (string, error) {
							var x uint32
							var s uint8
							for i := 0; i < 5; i++ {
								slog.Debug("reading string length byte", "i", i)
								b, err := r.ReadByte()
								if err != nil {
									if i > 0 && err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									return "", fmt.Errorf("failed to read string length byte: %w", err)
								}
								if s == 28 && b > 0x0f {
									return "", errors.New("string length overflows a 32-bit integer")
								}
								if b < 0x80 {
									x = x | uint32(b)<<s
									if x == 0 {
										return "", nil
									}
									buf := make([]byte, x)
									slog.Debug("reading string bytes", "len", x)
									_, err = r.Read(buf)
									if err != nil {
										return "", fmt.Errorf("failed to read string bytes: %w", err)
									}
									if !utf8.Valid(buf) {
										return string(buf), errors.New("string is not valid UTF-8")
									}
									return string(buf), nil
								}
								x |= uint32(b&0x7f) << s
								s += 7
							}
							return "", errors.New("string length overflows a 32-bit integer")
						}(r)
						if err != nil {
							return nil, fmt.Errorf("failed to read `unknown` payload: %w", err)
						}
						return v.SetUnknown(payload), nil
					default:
						return nil, fmt.Errorf("unknown discriminant value %d", n)
					}
				}(r, path...)
				return (*Error)(v), err
			}()

			if err != nil {
				return nil, fmt.Errorf("failed to read `result::err` value: %w", err)
			}
			return &wrpc.Result[string, Error]{Err: v}, nil
		default:
			return nil, fmt.Errorf("invalid result status byte %d", status)
		}
	}(r__, []uint32{0}...)
	if err__ != nil {
		err__ = fmt.Errorf("failed to read result 0: %w", err__)
		return
	}
	return
}

// Update an existing Kubernetes resource.
// @param resource The resource to update.
// @returns The status of the update operation.
func Update(ctx__ context.Context, wrpc__ wrpc.Invoker, k8sResource *k8s__provider__types.KubernetesResource) (r0__ *wrpc.Result[string, Error], err__ error) {
	var buf__ bytes.Buffer
	write0__, err__ := (k8sResource).WriteToIndex(&buf__)
	if err__ != nil {
		err__ = fmt.Errorf("failed to write `k8s-resource` parameter: %w", err__)
		return
	}
	if write0__ != nil {
		err__ = errors.New("unexpected deferred write for synchronous `k8s-resource` parameter")
		return
	}
	var w__ wrpc.IndexWriteCloser
	var r__ wrpc.IndexReadCloser
	w__, r__, err__ = wrpc__.Invoke(ctx__, "k8s:provider/request@0.1.0", "update", buf__.Bytes())
	if err__ != nil {
		err__ = fmt.Errorf("failed to invoke `update`: %w", err__)
		return
	}
	defer func() {
		if err := r__.Close(); err != nil {
			slog.ErrorContext(ctx__, "failed to close reader", "instance", "k8s:provider/request@0.1.0", "name", "update", "err", err)
		}
	}()
	if cErr__ := w__.Close(); cErr__ != nil {
		slog.DebugContext(ctx__, "failed to close outgoing stream", "instance", "k8s:provider/request@0.1.0", "name", "update", "err", cErr__)
	}
	r0__, err__ = func(r wrpc.IndexReadCloser, path ...uint32) (*wrpc.Result[string, Error], error) {
		slog.Debug("reading result status byte")
		status, err := r.ReadByte()
		if err != nil {
			return nil, fmt.Errorf("failed to read result status byte: %w", err)
		}
		switch status {
		case 0:
			slog.Debug("reading `result::ok` payload")
			v, err := func(r interface {
				io.ByteReader
				io.Reader
			}) (string, error) {
				var x uint32
				var s uint8
				for i := 0; i < 5; i++ {
					slog.Debug("reading string length byte", "i", i)
					b, err := r.ReadByte()
					if err != nil {
						if i > 0 && err == io.EOF {
							err = io.ErrUnexpectedEOF
						}
						return "", fmt.Errorf("failed to read string length byte: %w", err)
					}
					if s == 28 && b > 0x0f {
						return "", errors.New("string length overflows a 32-bit integer")
					}
					if b < 0x80 {
						x = x | uint32(b)<<s
						if x == 0 {
							return "", nil
						}
						buf := make([]byte, x)
						slog.Debug("reading string bytes", "len", x)
						_, err = r.Read(buf)
						if err != nil {
							return "", fmt.Errorf("failed to read string bytes: %w", err)
						}
						if !utf8.Valid(buf) {
							return string(buf), errors.New("string is not valid UTF-8")
						}
						return string(buf), nil
					}
					x |= uint32(b&0x7f) << s
					s += 7
				}
				return "", errors.New("string length overflows a 32-bit integer")
			}(r)
			if err != nil {
				return nil, fmt.Errorf("failed to read `result::ok` value: %w", err)
			}
			return &wrpc.Result[string, Error]{Ok: &v}, nil
		case 1:
			slog.Debug("reading `result::err` payload")
			v, err := func() (*Error, error) {
				v, err := func(r wrpc.IndexReadCloser, path ...uint32) (*k8s__provider__types.Error, error) {
					v := &k8s__provider__types.Error{}
					n, err := func(r io.ByteReader) (uint8, error) {
						var x uint8
						var s uint
						for i := 0; i < 2; i++ {
							slog.Debug("reading u8 discriminant byte", "i", i)
							b, err := r.ReadByte()
							if err != nil {
								if i > 0 && err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								return x, fmt.Errorf("failed to read u8 discriminant byte: %w", err)
							}
							if s == 7 && b > 0x01 {
								return x, errors.New("discriminant overflows an 8-bit integer")
							}
							if b < 0x80 {
								return x | uint8(b)<<s, nil
							}
							x |= uint8(b&0x7f) << s
							s += 7
						}
						return x, errors.New("discriminant overflows an 8-bit integer")
					}(r)
					if err != nil {
						return nil, fmt.Errorf("failed to read discriminant: %w", err)
					}
					switch k8s__provider__types.ErrorDiscriminant(n) {
					case k8s__provider__types.ErrorNotFound:
						payload, err := func(r interface {
							io.ByteReader
							io.Reader
						}) (string, error) {
							var x uint32
							var s uint8
							for i := 0; i < 5; i++ {
								slog.Debug("reading string length byte", "i", i)
								b, err := r.ReadByte()
								if err != nil {
									if i > 0 && err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									return "", fmt.Errorf("failed to read string length byte: %w", err)
								}
								if s == 28 && b > 0x0f {
									return "", errors.New("string length overflows a 32-bit integer")
								}
								if b < 0x80 {
									x = x | uint32(b)<<s
									if x == 0 {
										return "", nil
									}
									buf := make([]byte, x)
									slog.Debug("reading string bytes", "len", x)
									_, err = r.Read(buf)
									if err != nil {
										return "", fmt.Errorf("failed to read string bytes: %w", err)
									}
									if !utf8.Valid(buf) {
										return string(buf), errors.New("string is not valid UTF-8")
									}
									return string(buf), nil
								}
								x |= uint32(b&0x7f) << s
								s += 7
							}
							return "", errors.New("string length overflows a 32-bit integer")
						}(r)
						if err != nil {
							return nil, fmt.Errorf("failed to read `not-found` payload: %w", err)
						}
						return v.SetNotFound(payload), nil
					case k8s__provider__types.ErrorAlreadyExists:
						payload, err := func(r interface {
							io.ByteReader
							io.Reader
						}) (string, error) {
							var x uint32
							var s uint8
							for i := 0; i < 5; i++ {
								slog.Debug("reading string length byte", "i", i)
								b, err := r.ReadByte()
								if err != nil {
									if i > 0 && err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									return "", fmt.Errorf("failed to read string length byte: %w", err)
								}
								if s == 28 && b > 0x0f {
									return "", errors.New("string length overflows a 32-bit integer")
								}
								if b < 0x80 {
									x = x | uint32(b)<<s
									if x == 0 {
										return "", nil
									}
									buf := make([]byte, x)
									slog.Debug("reading string bytes", "len", x)
									_, err = r.Read(buf)
									if err != nil {
										return "", fmt.Errorf("failed to read string bytes: %w", err)
									}
									if !utf8.Valid(buf) {
										return string(buf), errors.New("string is not valid UTF-8")
									}
									return string(buf), nil
								}
								x |= uint32(b&0x7f) << s
								s += 7
							}
							return "", errors.New("string length overflows a 32-bit integer")
						}(r)
						if err != nil {
							return nil, fmt.Errorf("failed to read `already-exists` payload: %w", err)
						}
						return v.SetAlreadyExists(payload), nil
					case k8s__provider__types.ErrorInvalidInput:
						payload, err := func(r interface {
							io.ByteReader
							io.Reader
						}) (string, error) {
							var x uint32
							var s uint8
							for i := 0; i < 5; i++ {
								slog.Debug("reading string length byte", "i", i)
								b, err := r.ReadByte()
								if err != nil {
									if i > 0 && err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									return "", fmt.Errorf("failed to read string length byte: %w", err)
								}
								if s == 28 && b > 0x0f {
									return "", errors.New("string length overflows a 32-bit integer")
								}
								if b < 0x80 {
									x = x | uint32(b)<<s
									if x == 0 {
										return "", nil
									}
									buf := make([]byte, x)
									slog.Debug("reading string bytes", "len", x)
									_, err = r.Read(buf)
									if err != nil {
										return "", fmt.Errorf("failed to read string bytes: %w", err)
									}
									if !utf8.Valid(buf) {
										return string(buf), errors.New("string is not valid UTF-8")
									}
									return string(buf), nil
								}
								x |= uint32(b&0x7f) << s
								s += 7
							}
							return "", errors.New("string length overflows a 32-bit integer")
						}(r)
						if err != nil {
							return nil, fmt.Errorf("failed to read `invalid-input` payload: %w", err)
						}
						return v.SetInvalidInput(payload), nil
					case k8s__provider__types.ErrorPermissionDenied:
						payload, err := func(r interface {
							io.ByteReader
							io.Reader
						}) (string, error) {
							var x uint32
							var s uint8
							for i := 0; i < 5; i++ {
								slog.Debug("reading string length byte", "i", i)
								b, err := r.ReadByte()
								if err != nil {
									if i > 0 && err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									return "", fmt.Errorf("failed to read string length byte: %w", err)
								}
								if s == 28 && b > 0x0f {
									return "", errors.New("string length overflows a 32-bit integer")
								}
								if b < 0x80 {
									x = x | uint32(b)<<s
									if x == 0 {
										return "", nil
									}
									buf := make([]byte, x)
									slog.Debug("reading string bytes", "len", x)
									_, err = r.Read(buf)
									if err != nil {
										return "", fmt.Errorf("failed to read string bytes: %w", err)
									}
									if !utf8.Valid(buf) {
										return string(buf), errors.New("string is not valid UTF-8")
									}
									return string(buf), nil
								}
								x |= uint32(b&0x7f) << s
								s += 7
							}
							return "", errors.New("string length overflows a 32-bit integer")
						}(r)
						if err != nil {
							return nil, fmt.Errorf("failed to read `permission-denied` payload: %w", err)
						}
						return v.SetPermissionDenied(payload), nil
					case k8s__provider__types.ErrorUnknown:
						payload, err := func(r interface {
							io.ByteReader
							io.Reader
						}) (string, error) {
							var x uint32
							var s uint8
							for i := 0; i < 5; i++ {
								slog.Debug("reading string length byte", "i", i)
								b, err := r.ReadByte()
								if err != nil {
									if i > 0 && err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									return "", fmt.Errorf("failed to read string length byte: %w", err)
								}
								if s == 28 && b > 0x0f {
									return "", errors.New("string length overflows a 32-bit integer")
								}
								if b < 0x80 {
									x = x | uint32(b)<<s
									if x == 0 {
										return "", nil
									}
									buf := make([]byte, x)
									slog.Debug("reading string bytes", "len", x)
									_, err = r.Read(buf)
									if err != nil {
										return "", fmt.Errorf("failed to read string bytes: %w", err)
									}
									if !utf8.Valid(buf) {
										return string(buf), errors.New("string is not valid UTF-8")
									}
									return string(buf), nil
								}
								x |= uint32(b&0x7f) << s
								s += 7
							}
							return "", errors.New("string length overflows a 32-bit integer")
						}(r)
						if err != nil {
							return nil, fmt.Errorf("failed to read `unknown` payload: %w", err)
						}
						return v.SetUnknown(payload), nil
					default:
						return nil, fmt.Errorf("unknown discriminant value %d", n)
					}
				}(r, path...)
				return (*Error)(v), err
			}()

			if err != nil {
				return nil, fmt.Errorf("failed to read `result::err` value: %w", err)
			}
			return &wrpc.Result[string, Error]{Err: v}, nil
		default:
			return nil, fmt.Errorf("invalid result status byte %d", status)
		}
	}(r__, []uint32{0}...)
	if err__ != nil {
		err__ = fmt.Errorf("failed to read result 0: %w", err__)
		return
	}
	return
}

// Delete a Kubernetes resource.
// @param resource The resource to delete.
// @returns The status of the deletion operation.
func Delete(ctx__ context.Context, wrpc__ wrpc.Invoker, k8sResource *k8s__provider__types.KubernetesResource) (r0__ *wrpc.Result[string, Error], err__ error) {
	var buf__ bytes.Buffer
	write0__, err__ := (k8sResource).WriteToIndex(&buf__)
	if err__ != nil {
		err__ = fmt.Errorf("failed to write `k8s-resource` parameter: %w", err__)
		return
	}
	if write0__ != nil {
		err__ = errors.New("unexpected deferred write for synchronous `k8s-resource` parameter")
		return
	}
	var w__ wrpc.IndexWriteCloser
	var r__ wrpc.IndexReadCloser
	w__, r__, err__ = wrpc__.Invoke(ctx__, "k8s:provider/request@0.1.0", "delete", buf__.Bytes())
	if err__ != nil {
		err__ = fmt.Errorf("failed to invoke `delete`: %w", err__)
		return
	}
	defer func() {
		if err := r__.Close(); err != nil {
			slog.ErrorContext(ctx__, "failed to close reader", "instance", "k8s:provider/request@0.1.0", "name", "delete", "err", err)
		}
	}()
	if cErr__ := w__.Close(); cErr__ != nil {
		slog.DebugContext(ctx__, "failed to close outgoing stream", "instance", "k8s:provider/request@0.1.0", "name", "delete", "err", cErr__)
	}
	r0__, err__ = func(r wrpc.IndexReadCloser, path ...uint32) (*wrpc.Result[string, Error], error) {
		slog.Debug("reading result status byte")
		status, err := r.ReadByte()
		if err != nil {
			return nil, fmt.Errorf("failed to read result status byte: %w", err)
		}
		switch status {
		case 0:
			slog.Debug("reading `result::ok` payload")
			v, err := func(r interface {
				io.ByteReader
				io.Reader
			}) (string, error) {
				var x uint32
				var s uint8
				for i := 0; i < 5; i++ {
					slog.Debug("reading string length byte", "i", i)
					b, err := r.ReadByte()
					if err != nil {
						if i > 0 && err == io.EOF {
							err = io.ErrUnexpectedEOF
						}
						return "", fmt.Errorf("failed to read string length byte: %w", err)
					}
					if s == 28 && b > 0x0f {
						return "", errors.New("string length overflows a 32-bit integer")
					}
					if b < 0x80 {
						x = x | uint32(b)<<s
						if x == 0 {
							return "", nil
						}
						buf := make([]byte, x)
						slog.Debug("reading string bytes", "len", x)
						_, err = r.Read(buf)
						if err != nil {
							return "", fmt.Errorf("failed to read string bytes: %w", err)
						}
						if !utf8.Valid(buf) {
							return string(buf), errors.New("string is not valid UTF-8")
						}
						return string(buf), nil
					}
					x |= uint32(b&0x7f) << s
					s += 7
				}
				return "", errors.New("string length overflows a 32-bit integer")
			}(r)
			if err != nil {
				return nil, fmt.Errorf("failed to read `result::ok` value: %w", err)
			}
			return &wrpc.Result[string, Error]{Ok: &v}, nil
		case 1:
			slog.Debug("reading `result::err` payload")
			v, err := func() (*Error, error) {
				v, err := func(r wrpc.IndexReadCloser, path ...uint32) (*k8s__provider__types.Error, error) {
					v := &k8s__provider__types.Error{}
					n, err := func(r io.ByteReader) (uint8, error) {
						var x uint8
						var s uint
						for i := 0; i < 2; i++ {
							slog.Debug("reading u8 discriminant byte", "i", i)
							b, err := r.ReadByte()
							if err != nil {
								if i > 0 && err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								return x, fmt.Errorf("failed to read u8 discriminant byte: %w", err)
							}
							if s == 7 && b > 0x01 {
								return x, errors.New("discriminant overflows an 8-bit integer")
							}
							if b < 0x80 {
								return x | uint8(b)<<s, nil
							}
							x |= uint8(b&0x7f) << s
							s += 7
						}
						return x, errors.New("discriminant overflows an 8-bit integer")
					}(r)
					if err != nil {
						return nil, fmt.Errorf("failed to read discriminant: %w", err)
					}
					switch k8s__provider__types.ErrorDiscriminant(n) {
					case k8s__provider__types.ErrorNotFound:
						payload, err := func(r interface {
							io.ByteReader
							io.Reader
						}) (string, error) {
							var x uint32
							var s uint8
							for i := 0; i < 5; i++ {
								slog.Debug("reading string length byte", "i", i)
								b, err := r.ReadByte()
								if err != nil {
									if i > 0 && err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									return "", fmt.Errorf("failed to read string length byte: %w", err)
								}
								if s == 28 && b > 0x0f {
									return "", errors.New("string length overflows a 32-bit integer")
								}
								if b < 0x80 {
									x = x | uint32(b)<<s
									if x == 0 {
										return "", nil
									}
									buf := make([]byte, x)
									slog.Debug("reading string bytes", "len", x)
									_, err = r.Read(buf)
									if err != nil {
										return "", fmt.Errorf("failed to read string bytes: %w", err)
									}
									if !utf8.Valid(buf) {
										return string(buf), errors.New("string is not valid UTF-8")
									}
									return string(buf), nil
								}
								x |= uint32(b&0x7f) << s
								s += 7
							}
							return "", errors.New("string length overflows a 32-bit integer")
						}(r)
						if err != nil {
							return nil, fmt.Errorf("failed to read `not-found` payload: %w", err)
						}
						return v.SetNotFound(payload), nil
					case k8s__provider__types.ErrorAlreadyExists:
						payload, err := func(r interface {
							io.ByteReader
							io.Reader
						}) (string, error) {
							var x uint32
							var s uint8
							for i := 0; i < 5; i++ {
								slog.Debug("reading string length byte", "i", i)
								b, err := r.ReadByte()
								if err != nil {
									if i > 0 && err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									return "", fmt.Errorf("failed to read string length byte: %w", err)
								}
								if s == 28 && b > 0x0f {
									return "", errors.New("string length overflows a 32-bit integer")
								}
								if b < 0x80 {
									x = x | uint32(b)<<s
									if x == 0 {
										return "", nil
									}
									buf := make([]byte, x)
									slog.Debug("reading string bytes", "len", x)
									_, err = r.Read(buf)
									if err != nil {
										return "", fmt.Errorf("failed to read string bytes: %w", err)
									}
									if !utf8.Valid(buf) {
										return string(buf), errors.New("string is not valid UTF-8")
									}
									return string(buf), nil
								}
								x |= uint32(b&0x7f) << s
								s += 7
							}
							return "", errors.New("string length overflows a 32-bit integer")
						}(r)
						if err != nil {
							return nil, fmt.Errorf("failed to read `already-exists` payload: %w", err)
						}
						return v.SetAlreadyExists(payload), nil
					case k8s__provider__types.ErrorInvalidInput:
						payload, err := func(r interface {
							io.ByteReader
							io.Reader
						}) (string, error) {
							var x uint32
							var s uint8
							for i := 0; i < 5; i++ {
								slog.Debug("reading string length byte", "i", i)
								b, err := r.ReadByte()
								if err != nil {
									if i > 0 && err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									return "", fmt.Errorf("failed to read string length byte: %w", err)
								}
								if s == 28 && b > 0x0f {
									return "", errors.New("string length overflows a 32-bit integer")
								}
								if b < 0x80 {
									x = x | uint32(b)<<s
									if x == 0 {
										return "", nil
									}
									buf := make([]byte, x)
									slog.Debug("reading string bytes", "len", x)
									_, err = r.Read(buf)
									if err != nil {
										return "", fmt.Errorf("failed to read string bytes: %w", err)
									}
									if !utf8.Valid(buf) {
										return string(buf), errors.New("string is not valid UTF-8")
									}
									return string(buf), nil
								}
								x |= uint32(b&0x7f) << s
								s += 7
							}
							return "", errors.New("string length overflows a 32-bit integer")
						}(r)
						if err != nil {
							return nil, fmt.Errorf("failed to read `invalid-input` payload: %w", err)
						}
						return v.SetInvalidInput(payload), nil
					case k8s__provider__types.ErrorPermissionDenied:
						payload, err := func(r interface {
							io.ByteReader
							io.Reader
						}) (string, error) {
							var x uint32
							var s uint8
							for i := 0; i < 5; i++ {
								slog.Debug("reading string length byte", "i", i)
								b, err := r.ReadByte()
								if err != nil {
									if i > 0 && err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									return "", fmt.Errorf("failed to read string length byte: %w", err)
								}
								if s == 28 && b > 0x0f {
									return "", errors.New("string length overflows a 32-bit integer")
								}
								if b < 0x80 {
									x = x | uint32(b)<<s
									if x == 0 {
										return "", nil
									}
									buf := make([]byte, x)
									slog.Debug("reading string bytes", "len", x)
									_, err = r.Read(buf)
									if err != nil {
										return "", fmt.Errorf("failed to read string bytes: %w", err)
									}
									if !utf8.Valid(buf) {
										return string(buf), errors.New("string is not valid UTF-8")
									}
									return string(buf), nil
								}
								x |= uint32(b&0x7f) << s
								s += 7
							}
							return "", errors.New("string length overflows a 32-bit integer")
						}(r)
						if err != nil {
							return nil, fmt.Errorf("failed to read `permission-denied` payload: %w", err)
						}
						return v.SetPermissionDenied(payload), nil
					case k8s__provider__types.ErrorUnknown:
						payload, err := func(r interface {
							io.ByteReader
							io.Reader
						}) (string, error) {
							var x uint32
							var s uint8
							for i := 0; i < 5; i++ {
								slog.Debug("reading string length byte", "i", i)
								b, err := r.ReadByte()
								if err != nil {
									if i > 0 && err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									return "", fmt.Errorf("failed to read string length byte: %w", err)
								}
								if s == 28 && b > 0x0f {
									return "", errors.New("string length overflows a 32-bit integer")
								}
								if b < 0x80 {
									x = x | uint32(b)<<s
									if x == 0 {
										return "", nil
									}
									buf := make([]byte, x)
									slog.Debug("reading string bytes", "len", x)
									_, err = r.Read(buf)
									if err != nil {
										return "", fmt.Errorf("failed to read string bytes: %w", err)
									}
									if !utf8.Valid(buf) {
										return string(buf), errors.New("string is not valid UTF-8")
									}
									return string(buf), nil
								}
								x |= uint32(b&0x7f) << s
								s += 7
							}
							return "", errors.New("string length overflows a 32-bit integer")
						}(r)
						if err != nil {
							return nil, fmt.Errorf("failed to read `unknown` payload: %w", err)
						}
						return v.SetUnknown(payload), nil
					default:
						return nil, fmt.Errorf("unknown discriminant value %d", n)
					}
				}(r, path...)
				return (*Error)(v), err
			}()

			if err != nil {
				return nil, fmt.Errorf("failed to read `result::err` value: %w", err)
			}
			return &wrpc.Result[string, Error]{Err: v}, nil
		default:
			return nil, fmt.Errorf("invalid result status byte %d", status)
		}
	}(r__, []uint32{0}...)
	if err__ != nil {
		err__ = fmt.Errorf("failed to read result 0: %w", err__)
		return
	}
	return
}
