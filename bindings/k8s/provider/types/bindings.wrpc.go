// Generated by `wit-bindgen-wrpc-go` 0.11.0. DO NOT EDIT!
package types

import (
	binary "encoding/binary"
	errors "errors"
	fmt "fmt"
	io "io"
	slog "log/slog"
	math "math"
	sync "sync"
	atomic "sync/atomic"
	wrpc "wrpc.io/go"
)

// Metadata for a Kubernetes resource.
type Metadata struct {
	Name string
	// The name of the resource.
	Namespace string
	// The namespace of the resource.
	Labels []*wrpc.Tuple2[string, string]
	// Labels for the resource.
	Annotations []*wrpc.Tuple2[string, string]
}

func (v *Metadata) String() string { return "Metadata" }

func (v *Metadata) WriteToIndex(w wrpc.ByteWriter) (func(wrpc.IndexWriter) error, error) {
	writes := make(map[uint32]func(wrpc.IndexWriter) error, 4)
	slog.Debug("writing field", "name", "name")
	write0, err := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
		n := len(v)
		if n > math.MaxUint32 {
			return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
		}
		if err = func(v int, w io.Writer) error {
			b := make([]byte, binary.MaxVarintLen32)
			i := binary.PutUvarint(b, uint64(v))
			slog.Debug("writing string byte length", "len", n)
			_, err = w.Write(b[:i])
			return err
		}(n, w); err != nil {
			return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
		}
		slog.Debug("writing string bytes")
		_, err = w.Write([]byte(v))
		if err != nil {
			return fmt.Errorf("failed to write string bytes: %w", err)
		}
		return nil
	}(v.Name, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `name` field: %w", err)
	}
	if write0 != nil {
		writes[0] = write0
	}
	slog.Debug("writing field", "name", "namespace")
	write1, err := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
		n := len(v)
		if n > math.MaxUint32 {
			return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
		}
		if err = func(v int, w io.Writer) error {
			b := make([]byte, binary.MaxVarintLen32)
			i := binary.PutUvarint(b, uint64(v))
			slog.Debug("writing string byte length", "len", n)
			_, err = w.Write(b[:i])
			return err
		}(n, w); err != nil {
			return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
		}
		slog.Debug("writing string bytes")
		_, err = w.Write([]byte(v))
		if err != nil {
			return fmt.Errorf("failed to write string bytes: %w", err)
		}
		return nil
	}(v.Namespace, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `namespace` field: %w", err)
	}
	if write1 != nil {
		writes[1] = write1
	}
	slog.Debug("writing field", "name", "labels")
	write2, err := func(v []*wrpc.Tuple2[string, string], w interface {
		io.ByteWriter
		io.Writer
	}) (write func(wrpc.IndexWriter) error, err error) {
		n := len(v)
		if n > math.MaxUint32 {
			return nil, fmt.Errorf("list length of %d overflows a 32-bit integer", n)
		}
		if err = func(v int, w io.Writer) error {
			b := make([]byte, binary.MaxVarintLen32)
			i := binary.PutUvarint(b, uint64(v))
			slog.Debug("writing list length", "len", n)
			_, err = w.Write(b[:i])
			return err
		}(n, w); err != nil {
			return nil, fmt.Errorf("failed to write list length of %d: %w", n, err)
		}
		slog.Debug("writing list elements")
		writes := make(map[uint32]func(wrpc.IndexWriter) error, n)
		for i, e := range v {
			write, err := func(v *wrpc.Tuple2[string, string], w interface {
				io.ByteWriter
				io.Writer
			}) (func(wrpc.IndexWriter) error, error) {
				writes := make(map[uint32]func(wrpc.IndexWriter) error, 2)
				slog.Debug("writing tuple element 0")
				write0, err := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
					n := len(v)
					if n > math.MaxUint32 {
						return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
					}
					if err = func(v int, w io.Writer) error {
						b := make([]byte, binary.MaxVarintLen32)
						i := binary.PutUvarint(b, uint64(v))
						slog.Debug("writing string byte length", "len", n)
						_, err = w.Write(b[:i])
						return err
					}(n, w); err != nil {
						return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
					}
					slog.Debug("writing string bytes")
					_, err = w.Write([]byte(v))
					if err != nil {
						return fmt.Errorf("failed to write string bytes: %w", err)
					}
					return nil
				}(v.V0, w)
				if err != nil {
					return nil, fmt.Errorf("failed to write tuple element 0: %w", err)
				}
				if write0 != nil {
					writes[0] = write0
				}
				slog.Debug("writing tuple element 1")
				write1, err := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
					n := len(v)
					if n > math.MaxUint32 {
						return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
					}
					if err = func(v int, w io.Writer) error {
						b := make([]byte, binary.MaxVarintLen32)
						i := binary.PutUvarint(b, uint64(v))
						slog.Debug("writing string byte length", "len", n)
						_, err = w.Write(b[:i])
						return err
					}(n, w); err != nil {
						return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
					}
					slog.Debug("writing string bytes")
					_, err = w.Write([]byte(v))
					if err != nil {
						return fmt.Errorf("failed to write string bytes: %w", err)
					}
					return nil
				}(v.V1, w)
				if err != nil {
					return nil, fmt.Errorf("failed to write tuple element 1: %w", err)
				}
				if write1 != nil {
					writes[1] = write1
				}
				if len(writes) > 0 {
					return func(w wrpc.IndexWriter) error {
						var wg sync.WaitGroup
						var wgErr atomic.Value
						for index, write := range writes {
							wg.Add(1)
							w, err := w.Index(index)
							if err != nil {
								return fmt.Errorf("failed to index nested tuple writer: %w", err)
							}
							write := write
							go func() {
								defer wg.Done()
								if err := write(w); err != nil {
									wgErr.Store(err)
								}
							}()
						}
						wg.Wait()
						err := wgErr.Load()
						if err == nil {
							return nil
						}
						return err.(error)
					}, nil
				}
				return nil, nil
			}(e, w)
			if err != nil {
				return nil, fmt.Errorf("failed to write list element %d: %w", i, err)
			}
			if write != nil {
				writes[uint32(i)] = write
			}
		}
		if len(writes) > 0 {
			return func(w wrpc.IndexWriter) error {
				var wg sync.WaitGroup
				var wgErr atomic.Value
				for index, write := range writes {
					wg.Add(1)
					w, err := w.Index(index)
					if err != nil {
						return fmt.Errorf("failed to index nested list writer: %w", err)
					}
					write := write
					go func() {
						defer wg.Done()
						if err := write(w); err != nil {
							wgErr.Store(err)
						}
					}()
				}
				wg.Wait()
				err := wgErr.Load()
				if err == nil {
					return nil
				}
				return err.(error)
			}, nil
		}
		return nil, nil
	}(v.Labels, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `labels` field: %w", err)
	}
	if write2 != nil {
		writes[2] = write2
	}
	slog.Debug("writing field", "name", "annotations")
	write3, err := func(v []*wrpc.Tuple2[string, string], w interface {
		io.ByteWriter
		io.Writer
	}) (write func(wrpc.IndexWriter) error, err error) {
		n := len(v)
		if n > math.MaxUint32 {
			return nil, fmt.Errorf("list length of %d overflows a 32-bit integer", n)
		}
		if err = func(v int, w io.Writer) error {
			b := make([]byte, binary.MaxVarintLen32)
			i := binary.PutUvarint(b, uint64(v))
			slog.Debug("writing list length", "len", n)
			_, err = w.Write(b[:i])
			return err
		}(n, w); err != nil {
			return nil, fmt.Errorf("failed to write list length of %d: %w", n, err)
		}
		slog.Debug("writing list elements")
		writes := make(map[uint32]func(wrpc.IndexWriter) error, n)
		for i, e := range v {
			write, err := func(v *wrpc.Tuple2[string, string], w interface {
				io.ByteWriter
				io.Writer
			}) (func(wrpc.IndexWriter) error, error) {
				writes := make(map[uint32]func(wrpc.IndexWriter) error, 2)
				slog.Debug("writing tuple element 0")
				write0, err := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
					n := len(v)
					if n > math.MaxUint32 {
						return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
					}
					if err = func(v int, w io.Writer) error {
						b := make([]byte, binary.MaxVarintLen32)
						i := binary.PutUvarint(b, uint64(v))
						slog.Debug("writing string byte length", "len", n)
						_, err = w.Write(b[:i])
						return err
					}(n, w); err != nil {
						return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
					}
					slog.Debug("writing string bytes")
					_, err = w.Write([]byte(v))
					if err != nil {
						return fmt.Errorf("failed to write string bytes: %w", err)
					}
					return nil
				}(v.V0, w)
				if err != nil {
					return nil, fmt.Errorf("failed to write tuple element 0: %w", err)
				}
				if write0 != nil {
					writes[0] = write0
				}
				slog.Debug("writing tuple element 1")
				write1, err := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
					n := len(v)
					if n > math.MaxUint32 {
						return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
					}
					if err = func(v int, w io.Writer) error {
						b := make([]byte, binary.MaxVarintLen32)
						i := binary.PutUvarint(b, uint64(v))
						slog.Debug("writing string byte length", "len", n)
						_, err = w.Write(b[:i])
						return err
					}(n, w); err != nil {
						return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
					}
					slog.Debug("writing string bytes")
					_, err = w.Write([]byte(v))
					if err != nil {
						return fmt.Errorf("failed to write string bytes: %w", err)
					}
					return nil
				}(v.V1, w)
				if err != nil {
					return nil, fmt.Errorf("failed to write tuple element 1: %w", err)
				}
				if write1 != nil {
					writes[1] = write1
				}
				if len(writes) > 0 {
					return func(w wrpc.IndexWriter) error {
						var wg sync.WaitGroup
						var wgErr atomic.Value
						for index, write := range writes {
							wg.Add(1)
							w, err := w.Index(index)
							if err != nil {
								return fmt.Errorf("failed to index nested tuple writer: %w", err)
							}
							write := write
							go func() {
								defer wg.Done()
								if err := write(w); err != nil {
									wgErr.Store(err)
								}
							}()
						}
						wg.Wait()
						err := wgErr.Load()
						if err == nil {
							return nil
						}
						return err.(error)
					}, nil
				}
				return nil, nil
			}(e, w)
			if err != nil {
				return nil, fmt.Errorf("failed to write list element %d: %w", i, err)
			}
			if write != nil {
				writes[uint32(i)] = write
			}
		}
		if len(writes) > 0 {
			return func(w wrpc.IndexWriter) error {
				var wg sync.WaitGroup
				var wgErr atomic.Value
				for index, write := range writes {
					wg.Add(1)
					w, err := w.Index(index)
					if err != nil {
						return fmt.Errorf("failed to index nested list writer: %w", err)
					}
					write := write
					go func() {
						defer wg.Done()
						if err := write(w); err != nil {
							wgErr.Store(err)
						}
					}()
				}
				wg.Wait()
				err := wgErr.Load()
				if err == nil {
					return nil
				}
				return err.(error)
			}, nil
		}
		return nil, nil
	}(v.Annotations, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `annotations` field: %w", err)
	}
	if write3 != nil {
		writes[3] = write3
	}

	if len(writes) > 0 {
		return func(w wrpc.IndexWriter) error {
			var wg sync.WaitGroup
			var wgErr atomic.Value
			for index, write := range writes {
				wg.Add(1)
				w, err := w.Index(index)
				if err != nil {
					return fmt.Errorf("failed to index nested record writer: %w", err)
				}
				write := write
				go func() {
					defer wg.Done()
					if err := write(w); err != nil {
						wgErr.Store(err)
					}
				}()
			}
			wg.Wait()
			err := wgErr.Load()
			if err == nil {
				return nil
			}
			return err.(error)
		}, nil
	}
	return nil, nil
}

// Represents a Kubernetes resource (e.g., ConfigMap, Deployment, Service).
type KubernetesResource struct {
	ApiVersion string
	Kind       string
	Metadata   *Metadata
	Spec       string
}

func (v *KubernetesResource) String() string { return "KubernetesResource" }

func (v *KubernetesResource) WriteToIndex(w wrpc.ByteWriter) (func(wrpc.IndexWriter) error, error) {
	writes := make(map[uint32]func(wrpc.IndexWriter) error, 4)
	slog.Debug("writing field", "name", "api-version")
	write0, err := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
		n := len(v)
		if n > math.MaxUint32 {
			return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
		}
		if err = func(v int, w io.Writer) error {
			b := make([]byte, binary.MaxVarintLen32)
			i := binary.PutUvarint(b, uint64(v))
			slog.Debug("writing string byte length", "len", n)
			_, err = w.Write(b[:i])
			return err
		}(n, w); err != nil {
			return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
		}
		slog.Debug("writing string bytes")
		_, err = w.Write([]byte(v))
		if err != nil {
			return fmt.Errorf("failed to write string bytes: %w", err)
		}
		return nil
	}(v.ApiVersion, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `api-version` field: %w", err)
	}
	if write0 != nil {
		writes[0] = write0
	}
	slog.Debug("writing field", "name", "kind")
	write1, err := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
		n := len(v)
		if n > math.MaxUint32 {
			return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
		}
		if err = func(v int, w io.Writer) error {
			b := make([]byte, binary.MaxVarintLen32)
			i := binary.PutUvarint(b, uint64(v))
			slog.Debug("writing string byte length", "len", n)
			_, err = w.Write(b[:i])
			return err
		}(n, w); err != nil {
			return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
		}
		slog.Debug("writing string bytes")
		_, err = w.Write([]byte(v))
		if err != nil {
			return fmt.Errorf("failed to write string bytes: %w", err)
		}
		return nil
	}(v.Kind, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `kind` field: %w", err)
	}
	if write1 != nil {
		writes[1] = write1
	}
	slog.Debug("writing field", "name", "metadata")
	write2, err := (v.Metadata).WriteToIndex(w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `metadata` field: %w", err)
	}
	if write2 != nil {
		writes[2] = write2
	}
	slog.Debug("writing field", "name", "spec")
	write3, err := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
		n := len(v)
		if n > math.MaxUint32 {
			return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
		}
		if err = func(v int, w io.Writer) error {
			b := make([]byte, binary.MaxVarintLen32)
			i := binary.PutUvarint(b, uint64(v))
			slog.Debug("writing string byte length", "len", n)
			_, err = w.Write(b[:i])
			return err
		}(n, w); err != nil {
			return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
		}
		slog.Debug("writing string bytes")
		_, err = w.Write([]byte(v))
		if err != nil {
			return fmt.Errorf("failed to write string bytes: %w", err)
		}
		return nil
	}(v.Spec, w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `spec` field: %w", err)
	}
	if write3 != nil {
		writes[3] = write3
	}

	if len(writes) > 0 {
		return func(w wrpc.IndexWriter) error {
			var wg sync.WaitGroup
			var wgErr atomic.Value
			for index, write := range writes {
				wg.Add(1)
				w, err := w.Index(index)
				if err != nil {
					return fmt.Errorf("failed to index nested record writer: %w", err)
				}
				write := write
				go func() {
					defer wg.Done()
					if err := write(w); err != nil {
						wgErr.Store(err)
					}
				}()
			}
			wg.Wait()
			err := wgErr.Load()
			if err == nil {
				return nil
			}
			return err.(error)
		}, nil
	}
	return nil, nil
}

type Error struct {
	payload      any
	discriminant ErrorDiscriminant
}

func (v *Error) Discriminant() ErrorDiscriminant { return v.discriminant }

type ErrorDiscriminant uint8

const (
	ErrorNotFound ErrorDiscriminant = 0
	// Resource not found.
	ErrorAlreadyExists ErrorDiscriminant = 1
	// Resource already exists.
	ErrorInvalidInput ErrorDiscriminant = 2
	// Invalid input provided.
	ErrorPermissionDenied ErrorDiscriminant = 3
	// Permission denied.
	ErrorUnknown ErrorDiscriminant = 4
)

func (v *Error) String() string {
	switch v.discriminant {
	case ErrorNotFound:
		return "not-found"
	case ErrorAlreadyExists:
		return "already-exists"
	case ErrorInvalidInput:
		return "invalid-input"
	case ErrorPermissionDenied:
		return "permission-denied"
	case ErrorUnknown:
		return "unknown"
	default:
		panic("invalid variant")
	}
}
func (v *Error) GetNotFound() (payload string, ok bool) {
	if ok = (v.discriminant == ErrorNotFound); !ok {
		return
	}
	payload, ok = v.payload.(string)
	return
}
func (v *Error) SetNotFound(payload string) *Error {
	v.discriminant = ErrorNotFound
	v.payload = payload
	return v
}
func NewErrorNotFound(payload string) *Error {
	return (&Error{}).SetNotFound(
		payload)
}

// Resource not found.
func (v *Error) GetAlreadyExists() (payload string, ok bool) {
	if ok = (v.discriminant == ErrorAlreadyExists); !ok {
		return
	}
	payload, ok = v.payload.(string)
	return
}

// Resource not found.
func (v *Error) SetAlreadyExists(payload string) *Error {
	v.discriminant = ErrorAlreadyExists
	v.payload = payload
	return v
}

// Resource not found.
func NewErrorAlreadyExists(payload string) *Error {
	return (&Error{}).SetAlreadyExists(
		payload)
}

// Resource already exists.
func (v *Error) GetInvalidInput() (payload string, ok bool) {
	if ok = (v.discriminant == ErrorInvalidInput); !ok {
		return
	}
	payload, ok = v.payload.(string)
	return
}

// Resource already exists.
func (v *Error) SetInvalidInput(payload string) *Error {
	v.discriminant = ErrorInvalidInput
	v.payload = payload
	return v
}

// Resource already exists.
func NewErrorInvalidInput(payload string) *Error {
	return (&Error{}).SetInvalidInput(
		payload)
}

// Invalid input provided.
func (v *Error) GetPermissionDenied() (payload string, ok bool) {
	if ok = (v.discriminant == ErrorPermissionDenied); !ok {
		return
	}
	payload, ok = v.payload.(string)
	return
}

// Invalid input provided.
func (v *Error) SetPermissionDenied(payload string) *Error {
	v.discriminant = ErrorPermissionDenied
	v.payload = payload
	return v
}

// Invalid input provided.
func NewErrorPermissionDenied(payload string) *Error {
	return (&Error{}).SetPermissionDenied(
		payload)
}

// Permission denied.
func (v *Error) GetUnknown() (payload string, ok bool) {
	if ok = (v.discriminant == ErrorUnknown); !ok {
		return
	}
	payload, ok = v.payload.(string)
	return
}

// Permission denied.
func (v *Error) SetUnknown(payload string) *Error {
	v.discriminant = ErrorUnknown
	v.payload = payload
	return v
}

// Permission denied.
func NewErrorUnknown(payload string) *Error {
	return (&Error{}).SetUnknown(
		payload)
}
func (v *Error) Error() string { return v.String() }
func (v *Error) WriteToIndex(w wrpc.ByteWriter) (func(wrpc.IndexWriter) error, error) {
	if err := func(v uint8, w io.Writer) error {
		b := make([]byte, 2)
		i := binary.PutUvarint(b, uint64(v))
		slog.Debug("writing u8 discriminant")
		_, err := w.Write(b[:i])
		return err
	}(uint8(v.discriminant), w); err != nil {
		return nil, fmt.Errorf("failed to write discriminant: %w", err)
	}
	switch v.discriminant {
	case ErrorNotFound:
		payload, ok := v.payload.(string)
		if !ok {
			return nil, errors.New("invalid payload")
		}
		write, err := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(payload, w)
		if err != nil {
			return nil, fmt.Errorf("failed to write payload: %w", err)
		}

		if write != nil {
			return func(w wrpc.IndexWriter) error {
				w, err := w.Index(0)
				if err != nil {
					return fmt.Errorf("failed to index nested variant writer: %w", err)
				}
				return write(w)
			}, nil
		}
	case ErrorAlreadyExists:
		payload, ok := v.payload.(string)
		if !ok {
			return nil, errors.New("invalid payload")
		}
		write, err := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(payload, w)
		if err != nil {
			return nil, fmt.Errorf("failed to write payload: %w", err)
		}

		if write != nil {
			return func(w wrpc.IndexWriter) error {
				w, err := w.Index(1)
				if err != nil {
					return fmt.Errorf("failed to index nested variant writer: %w", err)
				}
				return write(w)
			}, nil
		}
	case ErrorInvalidInput:
		payload, ok := v.payload.(string)
		if !ok {
			return nil, errors.New("invalid payload")
		}
		write, err := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(payload, w)
		if err != nil {
			return nil, fmt.Errorf("failed to write payload: %w", err)
		}

		if write != nil {
			return func(w wrpc.IndexWriter) error {
				w, err := w.Index(2)
				if err != nil {
					return fmt.Errorf("failed to index nested variant writer: %w", err)
				}
				return write(w)
			}, nil
		}
	case ErrorPermissionDenied:
		payload, ok := v.payload.(string)
		if !ok {
			return nil, errors.New("invalid payload")
		}
		write, err := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(payload, w)
		if err != nil {
			return nil, fmt.Errorf("failed to write payload: %w", err)
		}

		if write != nil {
			return func(w wrpc.IndexWriter) error {
				w, err := w.Index(3)
				if err != nil {
					return fmt.Errorf("failed to index nested variant writer: %w", err)
				}
				return write(w)
			}, nil
		}
	case ErrorUnknown:
		payload, ok := v.payload.(string)
		if !ok {
			return nil, errors.New("invalid payload")
		}
		write, err := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(payload, w)
		if err != nil {
			return nil, fmt.Errorf("failed to write payload: %w", err)
		}

		if write != nil {
			return func(w wrpc.IndexWriter) error {
				w, err := w.Index(4)
				if err != nil {
					return fmt.Errorf("failed to index nested variant writer: %w", err)
				}
				return write(w)
			}, nil
		}
	default:
		return nil, errors.New("invalid variant")
	}
	return nil, nil
}

// event type
type EventType struct {
	payload      any
	discriminant EventTypeDiscriminant
}

func (v *EventType) Discriminant() EventTypeDiscriminant { return v.discriminant }

type EventTypeDiscriminant uint8

const (
	EventTypeAdded EventTypeDiscriminant = 0
	// Resource was added.
	EventTypeModified EventTypeDiscriminant = 1
	// Resource was modified.
	EventTypeDeleted EventTypeDiscriminant = 2
)

func (v *EventType) String() string {
	switch v.discriminant {
	case EventTypeAdded:
		return "added"
	case EventTypeModified:
		return "modified"
	case EventTypeDeleted:
		return "deleted"
	default:
		panic("invalid variant")
	}
}
func (v *EventType) GetAdded() (ok bool) {
	if ok = (v.discriminant == EventTypeAdded); !ok {
		return
	}
	return
}
func (v *EventType) SetAdded() *EventType {
	v.discriminant = EventTypeAdded
	v.payload = nil
	return v
}
func NewEventTypeAdded() *EventType {
	return (&EventType{}).SetAdded()
}

// Resource was added.
func (v *EventType) GetModified() (ok bool) {
	if ok = (v.discriminant == EventTypeModified); !ok {
		return
	}
	return
}

// Resource was added.
func (v *EventType) SetModified() *EventType {
	v.discriminant = EventTypeModified
	v.payload = nil
	return v
}

// Resource was added.
func NewEventTypeModified() *EventType {
	return (&EventType{}).SetModified()
}

// Resource was modified.
func (v *EventType) GetDeleted() (ok bool) {
	if ok = (v.discriminant == EventTypeDeleted); !ok {
		return
	}
	return
}

// Resource was modified.
func (v *EventType) SetDeleted() *EventType {
	v.discriminant = EventTypeDeleted
	v.payload = nil
	return v
}

// Resource was modified.
func NewEventTypeDeleted() *EventType {
	return (&EventType{}).SetDeleted()
}
func (v *EventType) WriteToIndex(w wrpc.ByteWriter) (func(wrpc.IndexWriter) error, error) {
	if err := func(v uint8, w io.Writer) error {
		b := make([]byte, 2)
		i := binary.PutUvarint(b, uint64(v))
		slog.Debug("writing u8 discriminant")
		_, err := w.Write(b[:i])
		return err
	}(uint8(v.discriminant), w); err != nil {
		return nil, fmt.Errorf("failed to write discriminant: %w", err)
	}
	switch v.discriminant {
	case EventTypeAdded:
	case EventTypeModified:
	case EventTypeDeleted:
	default:
		return nil, errors.New("invalid variant")
	}
	return nil, nil
}

// Represents an event related to a Kubernetes resource.
type ResourceEvent struct {
	EventType *EventType
	// The type of the event (added, modified, deleted).
	K8sResource *KubernetesResource
}

func (v *ResourceEvent) String() string { return "ResourceEvent" }

func (v *ResourceEvent) WriteToIndex(w wrpc.ByteWriter) (func(wrpc.IndexWriter) error, error) {
	writes := make(map[uint32]func(wrpc.IndexWriter) error, 2)
	slog.Debug("writing field", "name", "event-type")
	write0, err := (v.EventType).WriteToIndex(w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `event-type` field: %w", err)
	}
	if write0 != nil {
		writes[0] = write0
	}
	slog.Debug("writing field", "name", "k8s-resource")
	write1, err := (v.K8sResource).WriteToIndex(w)
	if err != nil {
		return nil, fmt.Errorf("failed to write `k8s-resource` field: %w", err)
	}
	if write1 != nil {
		writes[1] = write1
	}

	if len(writes) > 0 {
		return func(w wrpc.IndexWriter) error {
			var wg sync.WaitGroup
			var wgErr atomic.Value
			for index, write := range writes {
				wg.Add(1)
				w, err := w.Index(index)
				if err != nil {
					return fmt.Errorf("failed to index nested record writer: %w", err)
				}
				write := write
				go func() {
					defer wg.Done()
					if err := write(w); err != nil {
						wgErr.Store(err)
					}
				}()
			}
			wg.Wait()
			err := wgErr.Load()
			if err == nil {
				return nil
			}
			return err.(error)
		}, nil
	}
	return nil, nil
}
