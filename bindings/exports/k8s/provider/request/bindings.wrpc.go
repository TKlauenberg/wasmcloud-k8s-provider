// Generated by `wit-bindgen-wrpc-go` 0.11.0. DO NOT EDIT!
package request

import (
	bytes "bytes"
	context "context"
	binary "encoding/binary"
	errors "errors"
	fmt "fmt"
	k8s__provider__types "github.com/TKlauenberg/wasmcloud-k8s-provider/bindings/k8s/provider/types"
	io "io"
	slog "log/slog"
	math "math"
	utf8 "unicode/utf8"
	wrpc "wrpc.io/go"
)

type KubernetesResource = k8s__provider__types.KubernetesResource
type Error = k8s__provider__types.Error
type Handler interface {
	// Get information about a Kubernetes resource.
	// @param resource The resource to get information about.
	// @returns The resource information.
	Get(ctx__ context.Context, k8sResource *k8s__provider__types.KubernetesResource) (*wrpc.Result[KubernetesResource, Error], error)
	// Create a new Kubernetes resource.
	// @param resource The resource to create.
	// @returns The status of the creation operation.
	Create(ctx__ context.Context, k8sResource *k8s__provider__types.KubernetesResource) (*wrpc.Result[string, Error], error)
	// Update an existing Kubernetes resource.
	// @param resource The resource to update.
	// @returns The status of the update operation.
	Update(ctx__ context.Context, k8sResource *k8s__provider__types.KubernetesResource) (*wrpc.Result[string, Error], error)
	// Delete a Kubernetes resource.
	// @param resource The resource to delete.
	// @returns The status of the deletion operation.
	Delete(ctx__ context.Context, k8sResource *k8s__provider__types.KubernetesResource) (*wrpc.Result[string, Error], error)
}

func ServeInterface(s wrpc.Server, h Handler) (stop func() error, err error) {
	stops := make([]func() error, 0, 4)
	stop = func() error {
		for _, stop := range stops {
			if err := stop(); err != nil {
				return err
			}
		}
		return nil
	}

	stop0, err := s.Serve("k8s:provider/request@0.1.0", "get", func(ctx context.Context, w wrpc.IndexWriteCloser, r wrpc.IndexReadCloser) {
		defer func() {
			if err := w.Close(); err != nil {
				slog.DebugContext(ctx, "failed to close writer", "instance", "k8s:provider/request@0.1.0", "name", "get", "err", err)
			}
		}()
		slog.DebugContext(ctx, "reading parameter", "i", 0)
		p0, err := func() (*KubernetesResource, error) {
			v, err := func(r wrpc.IndexReadCloser, path ...uint32) (*k8s__provider__types.KubernetesResource, error) {
				v := &k8s__provider__types.KubernetesResource{}
				var err error
				slog.Debug("reading field", "name", "api-version")
				v.ApiVersion, err = func(r interface {
					io.ByteReader
					io.Reader
				}) (string, error) { var x uint32; var s uint8; for i := 0; i < 5; i++ {
					slog.Debug("reading string length byte", "i", i)
					b, err := r.ReadByte()
					if err != nil {
						if i > 0 && err == io.EOF {
							err = io.ErrUnexpectedEOF
						}
						return "", fmt.Errorf("failed to read string length byte: %w", err)
					}
					if s == 28 && b > 0x0f {
						return "", errors.New("string length overflows a 32-bit integer")
					}
					if b < 0x80 {
						x = x | uint32(b)<<s
						if x == 0 {
							return "", nil
						}
						buf := make([]byte, x)
						slog.Debug("reading string bytes", "len", x)
						_, err = r.Read(buf)
						if err != nil {
							return "", fmt.Errorf("failed to read string bytes: %w", err)
						}
						if !utf8.Valid(buf) {
							return string(buf), errors.New("string is not valid UTF-8")
						}
						return string(buf), nil
					}
					x |= uint32(b&0x7f) << s
					s += 7
				}; return "", errors.New("string length overflows a 32-bit integer") }(r)
				if err != nil {
					return nil, fmt.Errorf("failed to read `api-version` field: %w", err)
				}
				slog.Debug("reading field", "name", "kind")
				v.Kind, err = func(r interface {
					io.ByteReader
					io.Reader
				}) (string, error) {
					var x uint32
					var s uint8
					for i := 0; i < 5; i++ {
						slog.Debug("reading string length byte", "i", i)
						b, err := r.ReadByte()
						if err != nil {
							if i > 0 && err == io.EOF {
								err = io.ErrUnexpectedEOF
							}
							return "", fmt.Errorf("failed to read string length byte: %w", err)
						}
						if s == 28 && b > 0x0f {
							return "", errors.New("string length overflows a 32-bit integer")
						}
						if b < 0x80 {
							x = x | uint32(b)<<s
							if x == 0 {
								return "", nil
							}
							buf := make([]byte, x)
							slog.Debug("reading string bytes", "len", x)
							_, err = r.Read(buf)
							if err != nil {
								return "", fmt.Errorf("failed to read string bytes: %w", err)
							}
							if !utf8.Valid(buf) {
								return string(buf), errors.New("string is not valid UTF-8")
							}
							return string(buf), nil
						}
						x |= uint32(b&0x7f) << s
						s += 7
					}
					return "", errors.New("string length overflows a 32-bit integer")
				}(r)
				if err != nil {
					return nil, fmt.Errorf("failed to read `kind` field: %w", err)
				}
				slog.Debug("reading field", "name", "metadata")
				v.Metadata, err = func(r wrpc.IndexReadCloser, path ...uint32) (*k8s__provider__types.Metadata, error) {
					v := &k8s__provider__types.Metadata{}
					var err error
					slog.Debug("reading field", "name", "name")
					v.Name, err = func(r interface {
						io.ByteReader
						io.Reader
					}) (string, error) {
						var x uint32
						var s uint8
						for i := 0; i < 5; i++ {
							slog.Debug("reading string length byte", "i", i)
							b, err := r.ReadByte()
							if err != nil {
								if i > 0 && err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								return "", fmt.Errorf("failed to read string length byte: %w", err)
							}
							if s == 28 && b > 0x0f {
								return "", errors.New("string length overflows a 32-bit integer")
							}
							if b < 0x80 {
								x = x | uint32(b)<<s
								if x == 0 {
									return "", nil
								}
								buf := make([]byte, x)
								slog.Debug("reading string bytes", "len", x)
								_, err = r.Read(buf)
								if err != nil {
									return "", fmt.Errorf("failed to read string bytes: %w", err)
								}
								if !utf8.Valid(buf) {
									return string(buf), errors.New("string is not valid UTF-8")
								}
								return string(buf), nil
							}
							x |= uint32(b&0x7f) << s
							s += 7
						}
						return "", errors.New("string length overflows a 32-bit integer")
					}(r)
					if err != nil {
						return nil, fmt.Errorf("failed to read `name` field: %w", err)
					}
					slog.Debug("reading field", "name", "namespace")
					v.Namespace, err = func(r interface {
						io.ByteReader
						io.Reader
					}) (string, error) { var x uint32; var s uint8; for i := 0; i < 5; i++ {
						slog.Debug("reading string length byte", "i", i)
						b, err := r.ReadByte()
						if err != nil {
							if i > 0 && err == io.EOF {
								err = io.ErrUnexpectedEOF
							}
							return "", fmt.Errorf("failed to read string length byte: %w", err)
						}
						if s == 28 && b > 0x0f {
							return "", errors.New("string length overflows a 32-bit integer")
						}
						if b < 0x80 {
							x = x | uint32(b)<<s
							if x == 0 {
								return "", nil
							}
							buf := make([]byte, x)
							slog.Debug("reading string bytes", "len", x)
							_, err = r.Read(buf)
							if err != nil {
								return "", fmt.Errorf("failed to read string bytes: %w", err)
							}
							if !utf8.Valid(buf) {
								return string(buf), errors.New("string is not valid UTF-8")
							}
							return string(buf), nil
						}
						x |= uint32(b&0x7f) << s
						s += 7
					}; return "", errors.New("string length overflows a 32-bit integer") }(r)
					if err != nil {
						return nil, fmt.Errorf("failed to read `namespace` field: %w", err)
					}
					slog.Debug("reading field", "name", "labels")
					v.Labels, err = func(r wrpc.IndexReadCloser, path ...uint32) ([]*wrpc.Tuple2[string, string], error) {
						var x uint32
						var s uint
						for i := 0; i < 5; i++ {
							slog.Debug("reading list length byte", "i", i)
							b, err := r.ReadByte()
							if err != nil {
								if i > 0 && err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								return nil, fmt.Errorf("failed to read list length byte: %w", err)
							}
							if s == 28 && b > 0x0f {
								return nil, errors.New("list length overflows a 32-bit integer")
							}
							if b < 0x80 {
								x = x | uint32(b)<<s
								if x == 0 {
									return nil, nil
								}
								vs := make([]*wrpc.Tuple2[string, string], x)
								for i := range vs {
									slog.Debug("reading list element", "i", i)
									vs[i], err = func(r wrpc.IndexReadCloser, path ...uint32) (*wrpc.Tuple2[string, string], error) {
										v := &wrpc.Tuple2[string, string]{}
										var err error
										slog.Debug("reading tuple element 0")
										v.V0, err = func(r interface {
											io.ByteReader
											io.Reader
										}) (string, error) {
											var x uint32
											var s uint8
											for i := 0; i < 5; i++ {
												slog.Debug("reading string length byte", "i", i)
												b, err := r.ReadByte()
												if err != nil {
													if i > 0 && err == io.EOF {
														err = io.ErrUnexpectedEOF
													}
													return "", fmt.Errorf("failed to read string length byte: %w", err)
												}
												if s == 28 && b > 0x0f {
													return "", errors.New("string length overflows a 32-bit integer")
												}
												if b < 0x80 {
													x = x | uint32(b)<<s
													if x == 0 {
														return "", nil
													}
													buf := make([]byte, x)
													slog.Debug("reading string bytes", "len", x)
													_, err = r.Read(buf)
													if err != nil {
														return "", fmt.Errorf("failed to read string bytes: %w", err)
													}
													if !utf8.Valid(buf) {
														return string(buf), errors.New("string is not valid UTF-8")
													}
													return string(buf), nil
												}
												x |= uint32(b&0x7f) << s
												s += 7
											}
											return "", errors.New("string length overflows a 32-bit integer")
										}(r)
										if err != nil {
											return nil, fmt.Errorf("failed to read tuple element 0: %w", err)
										}
										slog.Debug("reading tuple element 1")
										v.V1, err = func(r interface {
											io.ByteReader
											io.Reader
										}) (string, error) {
											var x uint32
											var s uint8
											for i := 0; i < 5; i++ {
												slog.Debug("reading string length byte", "i", i)
												b, err := r.ReadByte()
												if err != nil {
													if i > 0 && err == io.EOF {
														err = io.ErrUnexpectedEOF
													}
													return "", fmt.Errorf("failed to read string length byte: %w", err)
												}
												if s == 28 && b > 0x0f {
													return "", errors.New("string length overflows a 32-bit integer")
												}
												if b < 0x80 {
													x = x | uint32(b)<<s
													if x == 0 {
														return "", nil
													}
													buf := make([]byte, x)
													slog.Debug("reading string bytes", "len", x)
													_, err = r.Read(buf)
													if err != nil {
														return "", fmt.Errorf("failed to read string bytes: %w", err)
													}
													if !utf8.Valid(buf) {
														return string(buf), errors.New("string is not valid UTF-8")
													}
													return string(buf), nil
												}
												x |= uint32(b&0x7f) << s
												s += 7
											}
											return "", errors.New("string length overflows a 32-bit integer")
										}(r)
										if err != nil {
											return nil, fmt.Errorf("failed to read tuple element 1: %w", err)
										}
										return v, nil
									}(r, append(path, uint32(i))...)
									if err != nil {
										return nil, fmt.Errorf("failed to read list element %d: %w", i, err)
									}
								}
								return vs, nil
							}
							x |= uint32(b&0x7f) << s
							s += 7
						}
						return nil, errors.New("list length overflows a 32-bit integer")
					}(r, append(path, 2)...)
					if err != nil {
						return nil, fmt.Errorf("failed to read `labels` field: %w", err)
					}
					slog.Debug("reading field", "name", "annotations")
					v.Annotations, err = func(r wrpc.IndexReadCloser, path ...uint32) ([]*wrpc.Tuple2[string, string], error) {
						var x uint32
						var s uint
						for i := 0; i < 5; i++ {
							slog.Debug("reading list length byte", "i", i)
							b, err := r.ReadByte()
							if err != nil {
								if i > 0 && err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								return nil, fmt.Errorf("failed to read list length byte: %w", err)
							}
							if s == 28 && b > 0x0f {
								return nil, errors.New("list length overflows a 32-bit integer")
							}
							if b < 0x80 {
								x = x | uint32(b)<<s
								if x == 0 {
									return nil, nil
								}
								vs := make([]*wrpc.Tuple2[string, string], x)
								for i := range vs {
									slog.Debug("reading list element", "i", i)
									vs[i], err = func(r wrpc.IndexReadCloser, path ...uint32) (*wrpc.Tuple2[string, string], error) {
										v := &wrpc.Tuple2[string, string]{}
										var err error
										slog.Debug("reading tuple element 0")
										v.V0, err = func(r interface {
											io.ByteReader
											io.Reader
										}) (string, error) {
											var x uint32
											var s uint8
											for i := 0; i < 5; i++ {
												slog.Debug("reading string length byte", "i", i)
												b, err := r.ReadByte()
												if err != nil {
													if i > 0 && err == io.EOF {
														err = io.ErrUnexpectedEOF
													}
													return "", fmt.Errorf("failed to read string length byte: %w", err)
												}
												if s == 28 && b > 0x0f {
													return "", errors.New("string length overflows a 32-bit integer")
												}
												if b < 0x80 {
													x = x | uint32(b)<<s
													if x == 0 {
														return "", nil
													}
													buf := make([]byte, x)
													slog.Debug("reading string bytes", "len", x)
													_, err = r.Read(buf)
													if err != nil {
														return "", fmt.Errorf("failed to read string bytes: %w", err)
													}
													if !utf8.Valid(buf) {
														return string(buf), errors.New("string is not valid UTF-8")
													}
													return string(buf), nil
												}
												x |= uint32(b&0x7f) << s
												s += 7
											}
											return "", errors.New("string length overflows a 32-bit integer")
										}(r)
										if err != nil {
											return nil, fmt.Errorf("failed to read tuple element 0: %w", err)
										}
										slog.Debug("reading tuple element 1")
										v.V1, err = func(r interface {
											io.ByteReader
											io.Reader
										}) (string, error) {
											var x uint32
											var s uint8
											for i := 0; i < 5; i++ {
												slog.Debug("reading string length byte", "i", i)
												b, err := r.ReadByte()
												if err != nil {
													if i > 0 && err == io.EOF {
														err = io.ErrUnexpectedEOF
													}
													return "", fmt.Errorf("failed to read string length byte: %w", err)
												}
												if s == 28 && b > 0x0f {
													return "", errors.New("string length overflows a 32-bit integer")
												}
												if b < 0x80 {
													x = x | uint32(b)<<s
													if x == 0 {
														return "", nil
													}
													buf := make([]byte, x)
													slog.Debug("reading string bytes", "len", x)
													_, err = r.Read(buf)
													if err != nil {
														return "", fmt.Errorf("failed to read string bytes: %w", err)
													}
													if !utf8.Valid(buf) {
														return string(buf), errors.New("string is not valid UTF-8")
													}
													return string(buf), nil
												}
												x |= uint32(b&0x7f) << s
												s += 7
											}
											return "", errors.New("string length overflows a 32-bit integer")
										}(r)
										if err != nil {
											return nil, fmt.Errorf("failed to read tuple element 1: %w", err)
										}
										return v, nil
									}(r, append(path, uint32(i))...)
									if err != nil {
										return nil, fmt.Errorf("failed to read list element %d: %w", i, err)
									}
								}
								return vs, nil
							}
							x |= uint32(b&0x7f) << s
							s += 7
						}
						return nil, errors.New("list length overflows a 32-bit integer")
					}(r, append(path, 3)...)
					if err != nil {
						return nil, fmt.Errorf("failed to read `annotations` field: %w", err)
					}
					return v, nil
				}(r, append(path, 2)...)
				if err != nil {
					return nil, fmt.Errorf("failed to read `metadata` field: %w", err)
				}
				slog.Debug("reading field", "name", "spec")
				v.Spec, err = func(r interface {
					io.ByteReader
					io.Reader
				}) (string, error) {
					var x uint32
					var s uint8
					for i := 0; i < 5; i++ {
						slog.Debug("reading string length byte", "i", i)
						b, err := r.ReadByte()
						if err != nil {
							if i > 0 && err == io.EOF {
								err = io.ErrUnexpectedEOF
							}
							return "", fmt.Errorf("failed to read string length byte: %w", err)
						}
						if s == 28 && b > 0x0f {
							return "", errors.New("string length overflows a 32-bit integer")
						}
						if b < 0x80 {
							x = x | uint32(b)<<s
							if x == 0 {
								return "", nil
							}
							buf := make([]byte, x)
							slog.Debug("reading string bytes", "len", x)
							_, err = r.Read(buf)
							if err != nil {
								return "", fmt.Errorf("failed to read string bytes: %w", err)
							}
							if !utf8.Valid(buf) {
								return string(buf), errors.New("string is not valid UTF-8")
							}
							return string(buf), nil
						}
						x |= uint32(b&0x7f) << s
						s += 7
					}
					return "", errors.New("string length overflows a 32-bit integer")
				}(r)
				if err != nil {
					return nil, fmt.Errorf("failed to read `spec` field: %w", err)
				}
				return v, nil
			}(r, []uint32{0}...)
			return (*KubernetesResource)(v), err
		}()

		if err != nil {
			slog.WarnContext(ctx, "failed to read parameter", "i", 0, "instance", "k8s:provider/request@0.1.0", "name", "get", "err", err)
			if err := r.Close(); err != nil {
				slog.ErrorContext(ctx, "failed to close reader", "instance", "k8s:provider/request@0.1.0", "name", "get", "err", err)
			}
			return
		}
		slog.DebugContext(ctx, "calling `k8s:provider/request@0.1.0.get` handler")
		r0, err := h.Get(ctx, p0)
		if cErr := r.Close(); cErr != nil {
			slog.ErrorContext(ctx, "failed to close reader", "instance", "k8s:provider/request@0.1.0", "name", "get", "err", err)
		}
		if err != nil {
			slog.WarnContext(ctx, "failed to handle invocation", "instance", "k8s:provider/request@0.1.0", "name", "get", "err", err)
			return
		}

		var buf bytes.Buffer
		writes := make(map[uint32]func(wrpc.IndexWriter) error, 1)

		write0, err := func(v *wrpc.Result[KubernetesResource, Error], w interface {
			io.ByteWriter
			io.Writer
		}) (func(wrpc.IndexWriter) error, error) {
			switch {
			case v.Ok == nil && v.Err == nil:
				return nil, errors.New("both result variants cannot be nil")
			case v.Ok != nil && v.Err != nil:
				return nil, errors.New("exactly one result variant must non-nil")

			case v.Ok != nil:
				slog.Debug("writing `result::ok` status byte")
				if err := w.WriteByte(0); err != nil {
					return nil, fmt.Errorf("failed to write `result::ok` status byte: %w", err)
				}
				slog.Debug("writing `result::ok` payload")
				write, err := (v.Ok).WriteToIndex(w)
				if err != nil {
					return nil, fmt.Errorf("failed to write `result::ok` payload: %w", err)
				}
				if write != nil {
					return write, nil
				}
				return nil, nil
			default:
				slog.Debug("writing `result::err` status byte")
				if err := w.WriteByte(1); err != nil {
					return nil, fmt.Errorf("failed to write `result::err` status byte: %w", err)
				}
				slog.Debug("writing `result::err` payload")
				write, err := (v.Err).WriteToIndex(w)
				if err != nil {
					return nil, fmt.Errorf("failed to write `result::err` payload: %w", err)
				}
				if write != nil {
					return write, nil
				}
				return nil, nil
			}
		}(r0, &buf)
		if err != nil {
			slog.WarnContext(ctx, "failed to write result value", "i", 0, "instance", "k8s:provider/request@0.1.0", "name", "get", "err", err)
			return
		}
		if write0 != nil {
			writes[0] = write0
		}
		slog.DebugContext(ctx, "transmitting `k8s:provider/request@0.1.0.get` result")
		_, err = w.Write(buf.Bytes())
		if err != nil {
			slog.WarnContext(ctx, "failed to write result", "instance", "k8s:provider/request@0.1.0", "name", "get", "err", err)
			return
		}
		if len(writes) > 0 {
			for index, write := range writes {
				_ = write
				switch index {
				case 0:
					w, err := w.Index(0)
					if err != nil {
						slog.ErrorContext(ctx, "failed to index result writer", "instance", "k8s:provider/request@0.1.0", "name", "get", "err", err)
						return
					}
					write := write
					go func() {
						if err := write(w); err != nil {
							slog.WarnContext(ctx, "failed to write nested result value", "instance", "k8s:provider/request@0.1.0", "name", "get", "err", err)
						}
					}()
				}
			}
		}
	})
	if err != nil {
		return nil, fmt.Errorf("failed to serve `k8s:provider/request@0.1.0.get`: %w", err)
	}
	stops = append(stops, stop0)

	stop1, err := s.Serve("k8s:provider/request@0.1.0", "create", func(ctx context.Context, w wrpc.IndexWriteCloser, r wrpc.IndexReadCloser) {
		defer func() {
			if err := w.Close(); err != nil {
				slog.DebugContext(ctx, "failed to close writer", "instance", "k8s:provider/request@0.1.0", "name", "create", "err", err)
			}
		}()
		slog.DebugContext(ctx, "reading parameter", "i", 0)
		p0, err := func() (*KubernetesResource, error) {
			v, err := func(r wrpc.IndexReadCloser, path ...uint32) (*k8s__provider__types.KubernetesResource, error) {
				v := &k8s__provider__types.KubernetesResource{}
				var err error
				slog.Debug("reading field", "name", "api-version")
				v.ApiVersion, err = func(r interface {
					io.ByteReader
					io.Reader
				}) (string, error) { var x uint32; var s uint8; for i := 0; i < 5; i++ {
					slog.Debug("reading string length byte", "i", i)
					b, err := r.ReadByte()
					if err != nil {
						if i > 0 && err == io.EOF {
							err = io.ErrUnexpectedEOF
						}
						return "", fmt.Errorf("failed to read string length byte: %w", err)
					}
					if s == 28 && b > 0x0f {
						return "", errors.New("string length overflows a 32-bit integer")
					}
					if b < 0x80 {
						x = x | uint32(b)<<s
						if x == 0 {
							return "", nil
						}
						buf := make([]byte, x)
						slog.Debug("reading string bytes", "len", x)
						_, err = r.Read(buf)
						if err != nil {
							return "", fmt.Errorf("failed to read string bytes: %w", err)
						}
						if !utf8.Valid(buf) {
							return string(buf), errors.New("string is not valid UTF-8")
						}
						return string(buf), nil
					}
					x |= uint32(b&0x7f) << s
					s += 7
				}; return "", errors.New("string length overflows a 32-bit integer") }(r)
				if err != nil {
					return nil, fmt.Errorf("failed to read `api-version` field: %w", err)
				}
				slog.Debug("reading field", "name", "kind")
				v.Kind, err = func(r interface {
					io.ByteReader
					io.Reader
				}) (string, error) {
					var x uint32
					var s uint8
					for i := 0; i < 5; i++ {
						slog.Debug("reading string length byte", "i", i)
						b, err := r.ReadByte()
						if err != nil {
							if i > 0 && err == io.EOF {
								err = io.ErrUnexpectedEOF
							}
							return "", fmt.Errorf("failed to read string length byte: %w", err)
						}
						if s == 28 && b > 0x0f {
							return "", errors.New("string length overflows a 32-bit integer")
						}
						if b < 0x80 {
							x = x | uint32(b)<<s
							if x == 0 {
								return "", nil
							}
							buf := make([]byte, x)
							slog.Debug("reading string bytes", "len", x)
							_, err = r.Read(buf)
							if err != nil {
								return "", fmt.Errorf("failed to read string bytes: %w", err)
							}
							if !utf8.Valid(buf) {
								return string(buf), errors.New("string is not valid UTF-8")
							}
							return string(buf), nil
						}
						x |= uint32(b&0x7f) << s
						s += 7
					}
					return "", errors.New("string length overflows a 32-bit integer")
				}(r)
				if err != nil {
					return nil, fmt.Errorf("failed to read `kind` field: %w", err)
				}
				slog.Debug("reading field", "name", "metadata")
				v.Metadata, err = func(r wrpc.IndexReadCloser, path ...uint32) (*k8s__provider__types.Metadata, error) {
					v := &k8s__provider__types.Metadata{}
					var err error
					slog.Debug("reading field", "name", "name")
					v.Name, err = func(r interface {
						io.ByteReader
						io.Reader
					}) (string, error) {
						var x uint32
						var s uint8
						for i := 0; i < 5; i++ {
							slog.Debug("reading string length byte", "i", i)
							b, err := r.ReadByte()
							if err != nil {
								if i > 0 && err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								return "", fmt.Errorf("failed to read string length byte: %w", err)
							}
							if s == 28 && b > 0x0f {
								return "", errors.New("string length overflows a 32-bit integer")
							}
							if b < 0x80 {
								x = x | uint32(b)<<s
								if x == 0 {
									return "", nil
								}
								buf := make([]byte, x)
								slog.Debug("reading string bytes", "len", x)
								_, err = r.Read(buf)
								if err != nil {
									return "", fmt.Errorf("failed to read string bytes: %w", err)
								}
								if !utf8.Valid(buf) {
									return string(buf), errors.New("string is not valid UTF-8")
								}
								return string(buf), nil
							}
							x |= uint32(b&0x7f) << s
							s += 7
						}
						return "", errors.New("string length overflows a 32-bit integer")
					}(r)
					if err != nil {
						return nil, fmt.Errorf("failed to read `name` field: %w", err)
					}
					slog.Debug("reading field", "name", "namespace")
					v.Namespace, err = func(r interface {
						io.ByteReader
						io.Reader
					}) (string, error) { var x uint32; var s uint8; for i := 0; i < 5; i++ {
						slog.Debug("reading string length byte", "i", i)
						b, err := r.ReadByte()
						if err != nil {
							if i > 0 && err == io.EOF {
								err = io.ErrUnexpectedEOF
							}
							return "", fmt.Errorf("failed to read string length byte: %w", err)
						}
						if s == 28 && b > 0x0f {
							return "", errors.New("string length overflows a 32-bit integer")
						}
						if b < 0x80 {
							x = x | uint32(b)<<s
							if x == 0 {
								return "", nil
							}
							buf := make([]byte, x)
							slog.Debug("reading string bytes", "len", x)
							_, err = r.Read(buf)
							if err != nil {
								return "", fmt.Errorf("failed to read string bytes: %w", err)
							}
							if !utf8.Valid(buf) {
								return string(buf), errors.New("string is not valid UTF-8")
							}
							return string(buf), nil
						}
						x |= uint32(b&0x7f) << s
						s += 7
					}; return "", errors.New("string length overflows a 32-bit integer") }(r)
					if err != nil {
						return nil, fmt.Errorf("failed to read `namespace` field: %w", err)
					}
					slog.Debug("reading field", "name", "labels")
					v.Labels, err = func(r wrpc.IndexReadCloser, path ...uint32) ([]*wrpc.Tuple2[string, string], error) {
						var x uint32
						var s uint
						for i := 0; i < 5; i++ {
							slog.Debug("reading list length byte", "i", i)
							b, err := r.ReadByte()
							if err != nil {
								if i > 0 && err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								return nil, fmt.Errorf("failed to read list length byte: %w", err)
							}
							if s == 28 && b > 0x0f {
								return nil, errors.New("list length overflows a 32-bit integer")
							}
							if b < 0x80 {
								x = x | uint32(b)<<s
								if x == 0 {
									return nil, nil
								}
								vs := make([]*wrpc.Tuple2[string, string], x)
								for i := range vs {
									slog.Debug("reading list element", "i", i)
									vs[i], err = func(r wrpc.IndexReadCloser, path ...uint32) (*wrpc.Tuple2[string, string], error) {
										v := &wrpc.Tuple2[string, string]{}
										var err error
										slog.Debug("reading tuple element 0")
										v.V0, err = func(r interface {
											io.ByteReader
											io.Reader
										}) (string, error) {
											var x uint32
											var s uint8
											for i := 0; i < 5; i++ {
												slog.Debug("reading string length byte", "i", i)
												b, err := r.ReadByte()
												if err != nil {
													if i > 0 && err == io.EOF {
														err = io.ErrUnexpectedEOF
													}
													return "", fmt.Errorf("failed to read string length byte: %w", err)
												}
												if s == 28 && b > 0x0f {
													return "", errors.New("string length overflows a 32-bit integer")
												}
												if b < 0x80 {
													x = x | uint32(b)<<s
													if x == 0 {
														return "", nil
													}
													buf := make([]byte, x)
													slog.Debug("reading string bytes", "len", x)
													_, err = r.Read(buf)
													if err != nil {
														return "", fmt.Errorf("failed to read string bytes: %w", err)
													}
													if !utf8.Valid(buf) {
														return string(buf), errors.New("string is not valid UTF-8")
													}
													return string(buf), nil
												}
												x |= uint32(b&0x7f) << s
												s += 7
											}
											return "", errors.New("string length overflows a 32-bit integer")
										}(r)
										if err != nil {
											return nil, fmt.Errorf("failed to read tuple element 0: %w", err)
										}
										slog.Debug("reading tuple element 1")
										v.V1, err = func(r interface {
											io.ByteReader
											io.Reader
										}) (string, error) {
											var x uint32
											var s uint8
											for i := 0; i < 5; i++ {
												slog.Debug("reading string length byte", "i", i)
												b, err := r.ReadByte()
												if err != nil {
													if i > 0 && err == io.EOF {
														err = io.ErrUnexpectedEOF
													}
													return "", fmt.Errorf("failed to read string length byte: %w", err)
												}
												if s == 28 && b > 0x0f {
													return "", errors.New("string length overflows a 32-bit integer")
												}
												if b < 0x80 {
													x = x | uint32(b)<<s
													if x == 0 {
														return "", nil
													}
													buf := make([]byte, x)
													slog.Debug("reading string bytes", "len", x)
													_, err = r.Read(buf)
													if err != nil {
														return "", fmt.Errorf("failed to read string bytes: %w", err)
													}
													if !utf8.Valid(buf) {
														return string(buf), errors.New("string is not valid UTF-8")
													}
													return string(buf), nil
												}
												x |= uint32(b&0x7f) << s
												s += 7
											}
											return "", errors.New("string length overflows a 32-bit integer")
										}(r)
										if err != nil {
											return nil, fmt.Errorf("failed to read tuple element 1: %w", err)
										}
										return v, nil
									}(r, append(path, uint32(i))...)
									if err != nil {
										return nil, fmt.Errorf("failed to read list element %d: %w", i, err)
									}
								}
								return vs, nil
							}
							x |= uint32(b&0x7f) << s
							s += 7
						}
						return nil, errors.New("list length overflows a 32-bit integer")
					}(r, append(path, 2)...)
					if err != nil {
						return nil, fmt.Errorf("failed to read `labels` field: %w", err)
					}
					slog.Debug("reading field", "name", "annotations")
					v.Annotations, err = func(r wrpc.IndexReadCloser, path ...uint32) ([]*wrpc.Tuple2[string, string], error) {
						var x uint32
						var s uint
						for i := 0; i < 5; i++ {
							slog.Debug("reading list length byte", "i", i)
							b, err := r.ReadByte()
							if err != nil {
								if i > 0 && err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								return nil, fmt.Errorf("failed to read list length byte: %w", err)
							}
							if s == 28 && b > 0x0f {
								return nil, errors.New("list length overflows a 32-bit integer")
							}
							if b < 0x80 {
								x = x | uint32(b)<<s
								if x == 0 {
									return nil, nil
								}
								vs := make([]*wrpc.Tuple2[string, string], x)
								for i := range vs {
									slog.Debug("reading list element", "i", i)
									vs[i], err = func(r wrpc.IndexReadCloser, path ...uint32) (*wrpc.Tuple2[string, string], error) {
										v := &wrpc.Tuple2[string, string]{}
										var err error
										slog.Debug("reading tuple element 0")
										v.V0, err = func(r interface {
											io.ByteReader
											io.Reader
										}) (string, error) {
											var x uint32
											var s uint8
											for i := 0; i < 5; i++ {
												slog.Debug("reading string length byte", "i", i)
												b, err := r.ReadByte()
												if err != nil {
													if i > 0 && err == io.EOF {
														err = io.ErrUnexpectedEOF
													}
													return "", fmt.Errorf("failed to read string length byte: %w", err)
												}
												if s == 28 && b > 0x0f {
													return "", errors.New("string length overflows a 32-bit integer")
												}
												if b < 0x80 {
													x = x | uint32(b)<<s
													if x == 0 {
														return "", nil
													}
													buf := make([]byte, x)
													slog.Debug("reading string bytes", "len", x)
													_, err = r.Read(buf)
													if err != nil {
														return "", fmt.Errorf("failed to read string bytes: %w", err)
													}
													if !utf8.Valid(buf) {
														return string(buf), errors.New("string is not valid UTF-8")
													}
													return string(buf), nil
												}
												x |= uint32(b&0x7f) << s
												s += 7
											}
											return "", errors.New("string length overflows a 32-bit integer")
										}(r)
										if err != nil {
											return nil, fmt.Errorf("failed to read tuple element 0: %w", err)
										}
										slog.Debug("reading tuple element 1")
										v.V1, err = func(r interface {
											io.ByteReader
											io.Reader
										}) (string, error) {
											var x uint32
											var s uint8
											for i := 0; i < 5; i++ {
												slog.Debug("reading string length byte", "i", i)
												b, err := r.ReadByte()
												if err != nil {
													if i > 0 && err == io.EOF {
														err = io.ErrUnexpectedEOF
													}
													return "", fmt.Errorf("failed to read string length byte: %w", err)
												}
												if s == 28 && b > 0x0f {
													return "", errors.New("string length overflows a 32-bit integer")
												}
												if b < 0x80 {
													x = x | uint32(b)<<s
													if x == 0 {
														return "", nil
													}
													buf := make([]byte, x)
													slog.Debug("reading string bytes", "len", x)
													_, err = r.Read(buf)
													if err != nil {
														return "", fmt.Errorf("failed to read string bytes: %w", err)
													}
													if !utf8.Valid(buf) {
														return string(buf), errors.New("string is not valid UTF-8")
													}
													return string(buf), nil
												}
												x |= uint32(b&0x7f) << s
												s += 7
											}
											return "", errors.New("string length overflows a 32-bit integer")
										}(r)
										if err != nil {
											return nil, fmt.Errorf("failed to read tuple element 1: %w", err)
										}
										return v, nil
									}(r, append(path, uint32(i))...)
									if err != nil {
										return nil, fmt.Errorf("failed to read list element %d: %w", i, err)
									}
								}
								return vs, nil
							}
							x |= uint32(b&0x7f) << s
							s += 7
						}
						return nil, errors.New("list length overflows a 32-bit integer")
					}(r, append(path, 3)...)
					if err != nil {
						return nil, fmt.Errorf("failed to read `annotations` field: %w", err)
					}
					return v, nil
				}(r, append(path, 2)...)
				if err != nil {
					return nil, fmt.Errorf("failed to read `metadata` field: %w", err)
				}
				slog.Debug("reading field", "name", "spec")
				v.Spec, err = func(r interface {
					io.ByteReader
					io.Reader
				}) (string, error) {
					var x uint32
					var s uint8
					for i := 0; i < 5; i++ {
						slog.Debug("reading string length byte", "i", i)
						b, err := r.ReadByte()
						if err != nil {
							if i > 0 && err == io.EOF {
								err = io.ErrUnexpectedEOF
							}
							return "", fmt.Errorf("failed to read string length byte: %w", err)
						}
						if s == 28 && b > 0x0f {
							return "", errors.New("string length overflows a 32-bit integer")
						}
						if b < 0x80 {
							x = x | uint32(b)<<s
							if x == 0 {
								return "", nil
							}
							buf := make([]byte, x)
							slog.Debug("reading string bytes", "len", x)
							_, err = r.Read(buf)
							if err != nil {
								return "", fmt.Errorf("failed to read string bytes: %w", err)
							}
							if !utf8.Valid(buf) {
								return string(buf), errors.New("string is not valid UTF-8")
							}
							return string(buf), nil
						}
						x |= uint32(b&0x7f) << s
						s += 7
					}
					return "", errors.New("string length overflows a 32-bit integer")
				}(r)
				if err != nil {
					return nil, fmt.Errorf("failed to read `spec` field: %w", err)
				}
				return v, nil
			}(r, []uint32{0}...)
			return (*KubernetesResource)(v), err
		}()

		if err != nil {
			slog.WarnContext(ctx, "failed to read parameter", "i", 0, "instance", "k8s:provider/request@0.1.0", "name", "create", "err", err)
			if err := r.Close(); err != nil {
				slog.ErrorContext(ctx, "failed to close reader", "instance", "k8s:provider/request@0.1.0", "name", "create", "err", err)
			}
			return
		}
		slog.DebugContext(ctx, "calling `k8s:provider/request@0.1.0.create` handler")
		r0, err := h.Create(ctx, p0)
		if cErr := r.Close(); cErr != nil {
			slog.ErrorContext(ctx, "failed to close reader", "instance", "k8s:provider/request@0.1.0", "name", "create", "err", err)
		}
		if err != nil {
			slog.WarnContext(ctx, "failed to handle invocation", "instance", "k8s:provider/request@0.1.0", "name", "create", "err", err)
			return
		}

		var buf bytes.Buffer
		writes := make(map[uint32]func(wrpc.IndexWriter) error, 1)

		write0, err := func(v *wrpc.Result[string, Error], w interface {
			io.ByteWriter
			io.Writer
		}) (func(wrpc.IndexWriter) error, error) {
			switch {
			case v.Ok == nil && v.Err == nil:
				return nil, errors.New("both result variants cannot be nil")
			case v.Ok != nil && v.Err != nil:
				return nil, errors.New("exactly one result variant must non-nil")

			case v.Ok != nil:
				slog.Debug("writing `result::ok` status byte")
				if err := w.WriteByte(0); err != nil {
					return nil, fmt.Errorf("failed to write `result::ok` status byte: %w", err)
				}
				slog.Debug("writing `result::ok` payload")
				write, err := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
					n := len(v)
					if n > math.MaxUint32 {
						return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
					}
					if err = func(v int, w io.Writer) error {
						b := make([]byte, binary.MaxVarintLen32)
						i := binary.PutUvarint(b, uint64(v))
						slog.Debug("writing string byte length", "len", n)
						_, err = w.Write(b[:i])
						return err
					}(n, w); err != nil {
						return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
					}
					slog.Debug("writing string bytes")
					_, err = w.Write([]byte(v))
					if err != nil {
						return fmt.Errorf("failed to write string bytes: %w", err)
					}
					return nil
				}(*v.Ok, w)
				if err != nil {
					return nil, fmt.Errorf("failed to write `result::ok` payload: %w", err)
				}
				if write != nil {
					return write, nil
				}
				return nil, nil
			default:
				slog.Debug("writing `result::err` status byte")
				if err := w.WriteByte(1); err != nil {
					return nil, fmt.Errorf("failed to write `result::err` status byte: %w", err)
				}
				slog.Debug("writing `result::err` payload")
				write, err := (v.Err).WriteToIndex(w)
				if err != nil {
					return nil, fmt.Errorf("failed to write `result::err` payload: %w", err)
				}
				if write != nil {
					return write, nil
				}
				return nil, nil
			}
		}(r0, &buf)
		if err != nil {
			slog.WarnContext(ctx, "failed to write result value", "i", 0, "instance", "k8s:provider/request@0.1.0", "name", "create", "err", err)
			return
		}
		if write0 != nil {
			writes[0] = write0
		}
		slog.DebugContext(ctx, "transmitting `k8s:provider/request@0.1.0.create` result")
		_, err = w.Write(buf.Bytes())
		if err != nil {
			slog.WarnContext(ctx, "failed to write result", "instance", "k8s:provider/request@0.1.0", "name", "create", "err", err)
			return
		}
		if len(writes) > 0 {
			for index, write := range writes {
				_ = write
				switch index {
				case 0:
					w, err := w.Index(0)
					if err != nil {
						slog.ErrorContext(ctx, "failed to index result writer", "instance", "k8s:provider/request@0.1.0", "name", "create", "err", err)
						return
					}
					write := write
					go func() {
						if err := write(w); err != nil {
							slog.WarnContext(ctx, "failed to write nested result value", "instance", "k8s:provider/request@0.1.0", "name", "create", "err", err)
						}
					}()
				}
			}
		}
	})
	if err != nil {
		return nil, fmt.Errorf("failed to serve `k8s:provider/request@0.1.0.create`: %w", err)
	}
	stops = append(stops, stop1)

	stop2, err := s.Serve("k8s:provider/request@0.1.0", "update", func(ctx context.Context, w wrpc.IndexWriteCloser, r wrpc.IndexReadCloser) {
		defer func() {
			if err := w.Close(); err != nil {
				slog.DebugContext(ctx, "failed to close writer", "instance", "k8s:provider/request@0.1.0", "name", "update", "err", err)
			}
		}()
		slog.DebugContext(ctx, "reading parameter", "i", 0)
		p0, err := func() (*KubernetesResource, error) {
			v, err := func(r wrpc.IndexReadCloser, path ...uint32) (*k8s__provider__types.KubernetesResource, error) {
				v := &k8s__provider__types.KubernetesResource{}
				var err error
				slog.Debug("reading field", "name", "api-version")
				v.ApiVersion, err = func(r interface {
					io.ByteReader
					io.Reader
				}) (string, error) { var x uint32; var s uint8; for i := 0; i < 5; i++ {
					slog.Debug("reading string length byte", "i", i)
					b, err := r.ReadByte()
					if err != nil {
						if i > 0 && err == io.EOF {
							err = io.ErrUnexpectedEOF
						}
						return "", fmt.Errorf("failed to read string length byte: %w", err)
					}
					if s == 28 && b > 0x0f {
						return "", errors.New("string length overflows a 32-bit integer")
					}
					if b < 0x80 {
						x = x | uint32(b)<<s
						if x == 0 {
							return "", nil
						}
						buf := make([]byte, x)
						slog.Debug("reading string bytes", "len", x)
						_, err = r.Read(buf)
						if err != nil {
							return "", fmt.Errorf("failed to read string bytes: %w", err)
						}
						if !utf8.Valid(buf) {
							return string(buf), errors.New("string is not valid UTF-8")
						}
						return string(buf), nil
					}
					x |= uint32(b&0x7f) << s
					s += 7
				}; return "", errors.New("string length overflows a 32-bit integer") }(r)
				if err != nil {
					return nil, fmt.Errorf("failed to read `api-version` field: %w", err)
				}
				slog.Debug("reading field", "name", "kind")
				v.Kind, err = func(r interface {
					io.ByteReader
					io.Reader
				}) (string, error) {
					var x uint32
					var s uint8
					for i := 0; i < 5; i++ {
						slog.Debug("reading string length byte", "i", i)
						b, err := r.ReadByte()
						if err != nil {
							if i > 0 && err == io.EOF {
								err = io.ErrUnexpectedEOF
							}
							return "", fmt.Errorf("failed to read string length byte: %w", err)
						}
						if s == 28 && b > 0x0f {
							return "", errors.New("string length overflows a 32-bit integer")
						}
						if b < 0x80 {
							x = x | uint32(b)<<s
							if x == 0 {
								return "", nil
							}
							buf := make([]byte, x)
							slog.Debug("reading string bytes", "len", x)
							_, err = r.Read(buf)
							if err != nil {
								return "", fmt.Errorf("failed to read string bytes: %w", err)
							}
							if !utf8.Valid(buf) {
								return string(buf), errors.New("string is not valid UTF-8")
							}
							return string(buf), nil
						}
						x |= uint32(b&0x7f) << s
						s += 7
					}
					return "", errors.New("string length overflows a 32-bit integer")
				}(r)
				if err != nil {
					return nil, fmt.Errorf("failed to read `kind` field: %w", err)
				}
				slog.Debug("reading field", "name", "metadata")
				v.Metadata, err = func(r wrpc.IndexReadCloser, path ...uint32) (*k8s__provider__types.Metadata, error) {
					v := &k8s__provider__types.Metadata{}
					var err error
					slog.Debug("reading field", "name", "name")
					v.Name, err = func(r interface {
						io.ByteReader
						io.Reader
					}) (string, error) {
						var x uint32
						var s uint8
						for i := 0; i < 5; i++ {
							slog.Debug("reading string length byte", "i", i)
							b, err := r.ReadByte()
							if err != nil {
								if i > 0 && err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								return "", fmt.Errorf("failed to read string length byte: %w", err)
							}
							if s == 28 && b > 0x0f {
								return "", errors.New("string length overflows a 32-bit integer")
							}
							if b < 0x80 {
								x = x | uint32(b)<<s
								if x == 0 {
									return "", nil
								}
								buf := make([]byte, x)
								slog.Debug("reading string bytes", "len", x)
								_, err = r.Read(buf)
								if err != nil {
									return "", fmt.Errorf("failed to read string bytes: %w", err)
								}
								if !utf8.Valid(buf) {
									return string(buf), errors.New("string is not valid UTF-8")
								}
								return string(buf), nil
							}
							x |= uint32(b&0x7f) << s
							s += 7
						}
						return "", errors.New("string length overflows a 32-bit integer")
					}(r)
					if err != nil {
						return nil, fmt.Errorf("failed to read `name` field: %w", err)
					}
					slog.Debug("reading field", "name", "namespace")
					v.Namespace, err = func(r interface {
						io.ByteReader
						io.Reader
					}) (string, error) { var x uint32; var s uint8; for i := 0; i < 5; i++ {
						slog.Debug("reading string length byte", "i", i)
						b, err := r.ReadByte()
						if err != nil {
							if i > 0 && err == io.EOF {
								err = io.ErrUnexpectedEOF
							}
							return "", fmt.Errorf("failed to read string length byte: %w", err)
						}
						if s == 28 && b > 0x0f {
							return "", errors.New("string length overflows a 32-bit integer")
						}
						if b < 0x80 {
							x = x | uint32(b)<<s
							if x == 0 {
								return "", nil
							}
							buf := make([]byte, x)
							slog.Debug("reading string bytes", "len", x)
							_, err = r.Read(buf)
							if err != nil {
								return "", fmt.Errorf("failed to read string bytes: %w", err)
							}
							if !utf8.Valid(buf) {
								return string(buf), errors.New("string is not valid UTF-8")
							}
							return string(buf), nil
						}
						x |= uint32(b&0x7f) << s
						s += 7
					}; return "", errors.New("string length overflows a 32-bit integer") }(r)
					if err != nil {
						return nil, fmt.Errorf("failed to read `namespace` field: %w", err)
					}
					slog.Debug("reading field", "name", "labels")
					v.Labels, err = func(r wrpc.IndexReadCloser, path ...uint32) ([]*wrpc.Tuple2[string, string], error) {
						var x uint32
						var s uint
						for i := 0; i < 5; i++ {
							slog.Debug("reading list length byte", "i", i)
							b, err := r.ReadByte()
							if err != nil {
								if i > 0 && err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								return nil, fmt.Errorf("failed to read list length byte: %w", err)
							}
							if s == 28 && b > 0x0f {
								return nil, errors.New("list length overflows a 32-bit integer")
							}
							if b < 0x80 {
								x = x | uint32(b)<<s
								if x == 0 {
									return nil, nil
								}
								vs := make([]*wrpc.Tuple2[string, string], x)
								for i := range vs {
									slog.Debug("reading list element", "i", i)
									vs[i], err = func(r wrpc.IndexReadCloser, path ...uint32) (*wrpc.Tuple2[string, string], error) {
										v := &wrpc.Tuple2[string, string]{}
										var err error
										slog.Debug("reading tuple element 0")
										v.V0, err = func(r interface {
											io.ByteReader
											io.Reader
										}) (string, error) {
											var x uint32
											var s uint8
											for i := 0; i < 5; i++ {
												slog.Debug("reading string length byte", "i", i)
												b, err := r.ReadByte()
												if err != nil {
													if i > 0 && err == io.EOF {
														err = io.ErrUnexpectedEOF
													}
													return "", fmt.Errorf("failed to read string length byte: %w", err)
												}
												if s == 28 && b > 0x0f {
													return "", errors.New("string length overflows a 32-bit integer")
												}
												if b < 0x80 {
													x = x | uint32(b)<<s
													if x == 0 {
														return "", nil
													}
													buf := make([]byte, x)
													slog.Debug("reading string bytes", "len", x)
													_, err = r.Read(buf)
													if err != nil {
														return "", fmt.Errorf("failed to read string bytes: %w", err)
													}
													if !utf8.Valid(buf) {
														return string(buf), errors.New("string is not valid UTF-8")
													}
													return string(buf), nil
												}
												x |= uint32(b&0x7f) << s
												s += 7
											}
											return "", errors.New("string length overflows a 32-bit integer")
										}(r)
										if err != nil {
											return nil, fmt.Errorf("failed to read tuple element 0: %w", err)
										}
										slog.Debug("reading tuple element 1")
										v.V1, err = func(r interface {
											io.ByteReader
											io.Reader
										}) (string, error) {
											var x uint32
											var s uint8
											for i := 0; i < 5; i++ {
												slog.Debug("reading string length byte", "i", i)
												b, err := r.ReadByte()
												if err != nil {
													if i > 0 && err == io.EOF {
														err = io.ErrUnexpectedEOF
													}
													return "", fmt.Errorf("failed to read string length byte: %w", err)
												}
												if s == 28 && b > 0x0f {
													return "", errors.New("string length overflows a 32-bit integer")
												}
												if b < 0x80 {
													x = x | uint32(b)<<s
													if x == 0 {
														return "", nil
													}
													buf := make([]byte, x)
													slog.Debug("reading string bytes", "len", x)
													_, err = r.Read(buf)
													if err != nil {
														return "", fmt.Errorf("failed to read string bytes: %w", err)
													}
													if !utf8.Valid(buf) {
														return string(buf), errors.New("string is not valid UTF-8")
													}
													return string(buf), nil
												}
												x |= uint32(b&0x7f) << s
												s += 7
											}
											return "", errors.New("string length overflows a 32-bit integer")
										}(r)
										if err != nil {
											return nil, fmt.Errorf("failed to read tuple element 1: %w", err)
										}
										return v, nil
									}(r, append(path, uint32(i))...)
									if err != nil {
										return nil, fmt.Errorf("failed to read list element %d: %w", i, err)
									}
								}
								return vs, nil
							}
							x |= uint32(b&0x7f) << s
							s += 7
						}
						return nil, errors.New("list length overflows a 32-bit integer")
					}(r, append(path, 2)...)
					if err != nil {
						return nil, fmt.Errorf("failed to read `labels` field: %w", err)
					}
					slog.Debug("reading field", "name", "annotations")
					v.Annotations, err = func(r wrpc.IndexReadCloser, path ...uint32) ([]*wrpc.Tuple2[string, string], error) {
						var x uint32
						var s uint
						for i := 0; i < 5; i++ {
							slog.Debug("reading list length byte", "i", i)
							b, err := r.ReadByte()
							if err != nil {
								if i > 0 && err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								return nil, fmt.Errorf("failed to read list length byte: %w", err)
							}
							if s == 28 && b > 0x0f {
								return nil, errors.New("list length overflows a 32-bit integer")
							}
							if b < 0x80 {
								x = x | uint32(b)<<s
								if x == 0 {
									return nil, nil
								}
								vs := make([]*wrpc.Tuple2[string, string], x)
								for i := range vs {
									slog.Debug("reading list element", "i", i)
									vs[i], err = func(r wrpc.IndexReadCloser, path ...uint32) (*wrpc.Tuple2[string, string], error) {
										v := &wrpc.Tuple2[string, string]{}
										var err error
										slog.Debug("reading tuple element 0")
										v.V0, err = func(r interface {
											io.ByteReader
											io.Reader
										}) (string, error) {
											var x uint32
											var s uint8
											for i := 0; i < 5; i++ {
												slog.Debug("reading string length byte", "i", i)
												b, err := r.ReadByte()
												if err != nil {
													if i > 0 && err == io.EOF {
														err = io.ErrUnexpectedEOF
													}
													return "", fmt.Errorf("failed to read string length byte: %w", err)
												}
												if s == 28 && b > 0x0f {
													return "", errors.New("string length overflows a 32-bit integer")
												}
												if b < 0x80 {
													x = x | uint32(b)<<s
													if x == 0 {
														return "", nil
													}
													buf := make([]byte, x)
													slog.Debug("reading string bytes", "len", x)
													_, err = r.Read(buf)
													if err != nil {
														return "", fmt.Errorf("failed to read string bytes: %w", err)
													}
													if !utf8.Valid(buf) {
														return string(buf), errors.New("string is not valid UTF-8")
													}
													return string(buf), nil
												}
												x |= uint32(b&0x7f) << s
												s += 7
											}
											return "", errors.New("string length overflows a 32-bit integer")
										}(r)
										if err != nil {
											return nil, fmt.Errorf("failed to read tuple element 0: %w", err)
										}
										slog.Debug("reading tuple element 1")
										v.V1, err = func(r interface {
											io.ByteReader
											io.Reader
										}) (string, error) {
											var x uint32
											var s uint8
											for i := 0; i < 5; i++ {
												slog.Debug("reading string length byte", "i", i)
												b, err := r.ReadByte()
												if err != nil {
													if i > 0 && err == io.EOF {
														err = io.ErrUnexpectedEOF
													}
													return "", fmt.Errorf("failed to read string length byte: %w", err)
												}
												if s == 28 && b > 0x0f {
													return "", errors.New("string length overflows a 32-bit integer")
												}
												if b < 0x80 {
													x = x | uint32(b)<<s
													if x == 0 {
														return "", nil
													}
													buf := make([]byte, x)
													slog.Debug("reading string bytes", "len", x)
													_, err = r.Read(buf)
													if err != nil {
														return "", fmt.Errorf("failed to read string bytes: %w", err)
													}
													if !utf8.Valid(buf) {
														return string(buf), errors.New("string is not valid UTF-8")
													}
													return string(buf), nil
												}
												x |= uint32(b&0x7f) << s
												s += 7
											}
											return "", errors.New("string length overflows a 32-bit integer")
										}(r)
										if err != nil {
											return nil, fmt.Errorf("failed to read tuple element 1: %w", err)
										}
										return v, nil
									}(r, append(path, uint32(i))...)
									if err != nil {
										return nil, fmt.Errorf("failed to read list element %d: %w", i, err)
									}
								}
								return vs, nil
							}
							x |= uint32(b&0x7f) << s
							s += 7
						}
						return nil, errors.New("list length overflows a 32-bit integer")
					}(r, append(path, 3)...)
					if err != nil {
						return nil, fmt.Errorf("failed to read `annotations` field: %w", err)
					}
					return v, nil
				}(r, append(path, 2)...)
				if err != nil {
					return nil, fmt.Errorf("failed to read `metadata` field: %w", err)
				}
				slog.Debug("reading field", "name", "spec")
				v.Spec, err = func(r interface {
					io.ByteReader
					io.Reader
				}) (string, error) {
					var x uint32
					var s uint8
					for i := 0; i < 5; i++ {
						slog.Debug("reading string length byte", "i", i)
						b, err := r.ReadByte()
						if err != nil {
							if i > 0 && err == io.EOF {
								err = io.ErrUnexpectedEOF
							}
							return "", fmt.Errorf("failed to read string length byte: %w", err)
						}
						if s == 28 && b > 0x0f {
							return "", errors.New("string length overflows a 32-bit integer")
						}
						if b < 0x80 {
							x = x | uint32(b)<<s
							if x == 0 {
								return "", nil
							}
							buf := make([]byte, x)
							slog.Debug("reading string bytes", "len", x)
							_, err = r.Read(buf)
							if err != nil {
								return "", fmt.Errorf("failed to read string bytes: %w", err)
							}
							if !utf8.Valid(buf) {
								return string(buf), errors.New("string is not valid UTF-8")
							}
							return string(buf), nil
						}
						x |= uint32(b&0x7f) << s
						s += 7
					}
					return "", errors.New("string length overflows a 32-bit integer")
				}(r)
				if err != nil {
					return nil, fmt.Errorf("failed to read `spec` field: %w", err)
				}
				return v, nil
			}(r, []uint32{0}...)
			return (*KubernetesResource)(v), err
		}()

		if err != nil {
			slog.WarnContext(ctx, "failed to read parameter", "i", 0, "instance", "k8s:provider/request@0.1.0", "name", "update", "err", err)
			if err := r.Close(); err != nil {
				slog.ErrorContext(ctx, "failed to close reader", "instance", "k8s:provider/request@0.1.0", "name", "update", "err", err)
			}
			return
		}
		slog.DebugContext(ctx, "calling `k8s:provider/request@0.1.0.update` handler")
		r0, err := h.Update(ctx, p0)
		if cErr := r.Close(); cErr != nil {
			slog.ErrorContext(ctx, "failed to close reader", "instance", "k8s:provider/request@0.1.0", "name", "update", "err", err)
		}
		if err != nil {
			slog.WarnContext(ctx, "failed to handle invocation", "instance", "k8s:provider/request@0.1.0", "name", "update", "err", err)
			return
		}

		var buf bytes.Buffer
		writes := make(map[uint32]func(wrpc.IndexWriter) error, 1)

		write0, err := func(v *wrpc.Result[string, Error], w interface {
			io.ByteWriter
			io.Writer
		}) (func(wrpc.IndexWriter) error, error) {
			switch {
			case v.Ok == nil && v.Err == nil:
				return nil, errors.New("both result variants cannot be nil")
			case v.Ok != nil && v.Err != nil:
				return nil, errors.New("exactly one result variant must non-nil")

			case v.Ok != nil:
				slog.Debug("writing `result::ok` status byte")
				if err := w.WriteByte(0); err != nil {
					return nil, fmt.Errorf("failed to write `result::ok` status byte: %w", err)
				}
				slog.Debug("writing `result::ok` payload")
				write, err := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
					n := len(v)
					if n > math.MaxUint32 {
						return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
					}
					if err = func(v int, w io.Writer) error {
						b := make([]byte, binary.MaxVarintLen32)
						i := binary.PutUvarint(b, uint64(v))
						slog.Debug("writing string byte length", "len", n)
						_, err = w.Write(b[:i])
						return err
					}(n, w); err != nil {
						return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
					}
					slog.Debug("writing string bytes")
					_, err = w.Write([]byte(v))
					if err != nil {
						return fmt.Errorf("failed to write string bytes: %w", err)
					}
					return nil
				}(*v.Ok, w)
				if err != nil {
					return nil, fmt.Errorf("failed to write `result::ok` payload: %w", err)
				}
				if write != nil {
					return write, nil
				}
				return nil, nil
			default:
				slog.Debug("writing `result::err` status byte")
				if err := w.WriteByte(1); err != nil {
					return nil, fmt.Errorf("failed to write `result::err` status byte: %w", err)
				}
				slog.Debug("writing `result::err` payload")
				write, err := (v.Err).WriteToIndex(w)
				if err != nil {
					return nil, fmt.Errorf("failed to write `result::err` payload: %w", err)
				}
				if write != nil {
					return write, nil
				}
				return nil, nil
			}
		}(r0, &buf)
		if err != nil {
			slog.WarnContext(ctx, "failed to write result value", "i", 0, "instance", "k8s:provider/request@0.1.0", "name", "update", "err", err)
			return
		}
		if write0 != nil {
			writes[0] = write0
		}
		slog.DebugContext(ctx, "transmitting `k8s:provider/request@0.1.0.update` result")
		_, err = w.Write(buf.Bytes())
		if err != nil {
			slog.WarnContext(ctx, "failed to write result", "instance", "k8s:provider/request@0.1.0", "name", "update", "err", err)
			return
		}
		if len(writes) > 0 {
			for index, write := range writes {
				_ = write
				switch index {
				case 0:
					w, err := w.Index(0)
					if err != nil {
						slog.ErrorContext(ctx, "failed to index result writer", "instance", "k8s:provider/request@0.1.0", "name", "update", "err", err)
						return
					}
					write := write
					go func() {
						if err := write(w); err != nil {
							slog.WarnContext(ctx, "failed to write nested result value", "instance", "k8s:provider/request@0.1.0", "name", "update", "err", err)
						}
					}()
				}
			}
		}
	})
	if err != nil {
		return nil, fmt.Errorf("failed to serve `k8s:provider/request@0.1.0.update`: %w", err)
	}
	stops = append(stops, stop2)

	stop3, err := s.Serve("k8s:provider/request@0.1.0", "delete", func(ctx context.Context, w wrpc.IndexWriteCloser, r wrpc.IndexReadCloser) {
		defer func() {
			if err := w.Close(); err != nil {
				slog.DebugContext(ctx, "failed to close writer", "instance", "k8s:provider/request@0.1.0", "name", "delete", "err", err)
			}
		}()
		slog.DebugContext(ctx, "reading parameter", "i", 0)
		p0, err := func() (*KubernetesResource, error) {
			v, err := func(r wrpc.IndexReadCloser, path ...uint32) (*k8s__provider__types.KubernetesResource, error) {
				v := &k8s__provider__types.KubernetesResource{}
				var err error
				slog.Debug("reading field", "name", "api-version")
				v.ApiVersion, err = func(r interface {
					io.ByteReader
					io.Reader
				}) (string, error) { var x uint32; var s uint8; for i := 0; i < 5; i++ {
					slog.Debug("reading string length byte", "i", i)
					b, err := r.ReadByte()
					if err != nil {
						if i > 0 && err == io.EOF {
							err = io.ErrUnexpectedEOF
						}
						return "", fmt.Errorf("failed to read string length byte: %w", err)
					}
					if s == 28 && b > 0x0f {
						return "", errors.New("string length overflows a 32-bit integer")
					}
					if b < 0x80 {
						x = x | uint32(b)<<s
						if x == 0 {
							return "", nil
						}
						buf := make([]byte, x)
						slog.Debug("reading string bytes", "len", x)
						_, err = r.Read(buf)
						if err != nil {
							return "", fmt.Errorf("failed to read string bytes: %w", err)
						}
						if !utf8.Valid(buf) {
							return string(buf), errors.New("string is not valid UTF-8")
						}
						return string(buf), nil
					}
					x |= uint32(b&0x7f) << s
					s += 7
				}; return "", errors.New("string length overflows a 32-bit integer") }(r)
				if err != nil {
					return nil, fmt.Errorf("failed to read `api-version` field: %w", err)
				}
				slog.Debug("reading field", "name", "kind")
				v.Kind, err = func(r interface {
					io.ByteReader
					io.Reader
				}) (string, error) {
					var x uint32
					var s uint8
					for i := 0; i < 5; i++ {
						slog.Debug("reading string length byte", "i", i)
						b, err := r.ReadByte()
						if err != nil {
							if i > 0 && err == io.EOF {
								err = io.ErrUnexpectedEOF
							}
							return "", fmt.Errorf("failed to read string length byte: %w", err)
						}
						if s == 28 && b > 0x0f {
							return "", errors.New("string length overflows a 32-bit integer")
						}
						if b < 0x80 {
							x = x | uint32(b)<<s
							if x == 0 {
								return "", nil
							}
							buf := make([]byte, x)
							slog.Debug("reading string bytes", "len", x)
							_, err = r.Read(buf)
							if err != nil {
								return "", fmt.Errorf("failed to read string bytes: %w", err)
							}
							if !utf8.Valid(buf) {
								return string(buf), errors.New("string is not valid UTF-8")
							}
							return string(buf), nil
						}
						x |= uint32(b&0x7f) << s
						s += 7
					}
					return "", errors.New("string length overflows a 32-bit integer")
				}(r)
				if err != nil {
					return nil, fmt.Errorf("failed to read `kind` field: %w", err)
				}
				slog.Debug("reading field", "name", "metadata")
				v.Metadata, err = func(r wrpc.IndexReadCloser, path ...uint32) (*k8s__provider__types.Metadata, error) {
					v := &k8s__provider__types.Metadata{}
					var err error
					slog.Debug("reading field", "name", "name")
					v.Name, err = func(r interface {
						io.ByteReader
						io.Reader
					}) (string, error) {
						var x uint32
						var s uint8
						for i := 0; i < 5; i++ {
							slog.Debug("reading string length byte", "i", i)
							b, err := r.ReadByte()
							if err != nil {
								if i > 0 && err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								return "", fmt.Errorf("failed to read string length byte: %w", err)
							}
							if s == 28 && b > 0x0f {
								return "", errors.New("string length overflows a 32-bit integer")
							}
							if b < 0x80 {
								x = x | uint32(b)<<s
								if x == 0 {
									return "", nil
								}
								buf := make([]byte, x)
								slog.Debug("reading string bytes", "len", x)
								_, err = r.Read(buf)
								if err != nil {
									return "", fmt.Errorf("failed to read string bytes: %w", err)
								}
								if !utf8.Valid(buf) {
									return string(buf), errors.New("string is not valid UTF-8")
								}
								return string(buf), nil
							}
							x |= uint32(b&0x7f) << s
							s += 7
						}
						return "", errors.New("string length overflows a 32-bit integer")
					}(r)
					if err != nil {
						return nil, fmt.Errorf("failed to read `name` field: %w", err)
					}
					slog.Debug("reading field", "name", "namespace")
					v.Namespace, err = func(r interface {
						io.ByteReader
						io.Reader
					}) (string, error) { var x uint32; var s uint8; for i := 0; i < 5; i++ {
						slog.Debug("reading string length byte", "i", i)
						b, err := r.ReadByte()
						if err != nil {
							if i > 0 && err == io.EOF {
								err = io.ErrUnexpectedEOF
							}
							return "", fmt.Errorf("failed to read string length byte: %w", err)
						}
						if s == 28 && b > 0x0f {
							return "", errors.New("string length overflows a 32-bit integer")
						}
						if b < 0x80 {
							x = x | uint32(b)<<s
							if x == 0 {
								return "", nil
							}
							buf := make([]byte, x)
							slog.Debug("reading string bytes", "len", x)
							_, err = r.Read(buf)
							if err != nil {
								return "", fmt.Errorf("failed to read string bytes: %w", err)
							}
							if !utf8.Valid(buf) {
								return string(buf), errors.New("string is not valid UTF-8")
							}
							return string(buf), nil
						}
						x |= uint32(b&0x7f) << s
						s += 7
					}; return "", errors.New("string length overflows a 32-bit integer") }(r)
					if err != nil {
						return nil, fmt.Errorf("failed to read `namespace` field: %w", err)
					}
					slog.Debug("reading field", "name", "labels")
					v.Labels, err = func(r wrpc.IndexReadCloser, path ...uint32) ([]*wrpc.Tuple2[string, string], error) {
						var x uint32
						var s uint
						for i := 0; i < 5; i++ {
							slog.Debug("reading list length byte", "i", i)
							b, err := r.ReadByte()
							if err != nil {
								if i > 0 && err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								return nil, fmt.Errorf("failed to read list length byte: %w", err)
							}
							if s == 28 && b > 0x0f {
								return nil, errors.New("list length overflows a 32-bit integer")
							}
							if b < 0x80 {
								x = x | uint32(b)<<s
								if x == 0 {
									return nil, nil
								}
								vs := make([]*wrpc.Tuple2[string, string], x)
								for i := range vs {
									slog.Debug("reading list element", "i", i)
									vs[i], err = func(r wrpc.IndexReadCloser, path ...uint32) (*wrpc.Tuple2[string, string], error) {
										v := &wrpc.Tuple2[string, string]{}
										var err error
										slog.Debug("reading tuple element 0")
										v.V0, err = func(r interface {
											io.ByteReader
											io.Reader
										}) (string, error) {
											var x uint32
											var s uint8
											for i := 0; i < 5; i++ {
												slog.Debug("reading string length byte", "i", i)
												b, err := r.ReadByte()
												if err != nil {
													if i > 0 && err == io.EOF {
														err = io.ErrUnexpectedEOF
													}
													return "", fmt.Errorf("failed to read string length byte: %w", err)
												}
												if s == 28 && b > 0x0f {
													return "", errors.New("string length overflows a 32-bit integer")
												}
												if b < 0x80 {
													x = x | uint32(b)<<s
													if x == 0 {
														return "", nil
													}
													buf := make([]byte, x)
													slog.Debug("reading string bytes", "len", x)
													_, err = r.Read(buf)
													if err != nil {
														return "", fmt.Errorf("failed to read string bytes: %w", err)
													}
													if !utf8.Valid(buf) {
														return string(buf), errors.New("string is not valid UTF-8")
													}
													return string(buf), nil
												}
												x |= uint32(b&0x7f) << s
												s += 7
											}
											return "", errors.New("string length overflows a 32-bit integer")
										}(r)
										if err != nil {
											return nil, fmt.Errorf("failed to read tuple element 0: %w", err)
										}
										slog.Debug("reading tuple element 1")
										v.V1, err = func(r interface {
											io.ByteReader
											io.Reader
										}) (string, error) {
											var x uint32
											var s uint8
											for i := 0; i < 5; i++ {
												slog.Debug("reading string length byte", "i", i)
												b, err := r.ReadByte()
												if err != nil {
													if i > 0 && err == io.EOF {
														err = io.ErrUnexpectedEOF
													}
													return "", fmt.Errorf("failed to read string length byte: %w", err)
												}
												if s == 28 && b > 0x0f {
													return "", errors.New("string length overflows a 32-bit integer")
												}
												if b < 0x80 {
													x = x | uint32(b)<<s
													if x == 0 {
														return "", nil
													}
													buf := make([]byte, x)
													slog.Debug("reading string bytes", "len", x)
													_, err = r.Read(buf)
													if err != nil {
														return "", fmt.Errorf("failed to read string bytes: %w", err)
													}
													if !utf8.Valid(buf) {
														return string(buf), errors.New("string is not valid UTF-8")
													}
													return string(buf), nil
												}
												x |= uint32(b&0x7f) << s
												s += 7
											}
											return "", errors.New("string length overflows a 32-bit integer")
										}(r)
										if err != nil {
											return nil, fmt.Errorf("failed to read tuple element 1: %w", err)
										}
										return v, nil
									}(r, append(path, uint32(i))...)
									if err != nil {
										return nil, fmt.Errorf("failed to read list element %d: %w", i, err)
									}
								}
								return vs, nil
							}
							x |= uint32(b&0x7f) << s
							s += 7
						}
						return nil, errors.New("list length overflows a 32-bit integer")
					}(r, append(path, 2)...)
					if err != nil {
						return nil, fmt.Errorf("failed to read `labels` field: %w", err)
					}
					slog.Debug("reading field", "name", "annotations")
					v.Annotations, err = func(r wrpc.IndexReadCloser, path ...uint32) ([]*wrpc.Tuple2[string, string], error) {
						var x uint32
						var s uint
						for i := 0; i < 5; i++ {
							slog.Debug("reading list length byte", "i", i)
							b, err := r.ReadByte()
							if err != nil {
								if i > 0 && err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								return nil, fmt.Errorf("failed to read list length byte: %w", err)
							}
							if s == 28 && b > 0x0f {
								return nil, errors.New("list length overflows a 32-bit integer")
							}
							if b < 0x80 {
								x = x | uint32(b)<<s
								if x == 0 {
									return nil, nil
								}
								vs := make([]*wrpc.Tuple2[string, string], x)
								for i := range vs {
									slog.Debug("reading list element", "i", i)
									vs[i], err = func(r wrpc.IndexReadCloser, path ...uint32) (*wrpc.Tuple2[string, string], error) {
										v := &wrpc.Tuple2[string, string]{}
										var err error
										slog.Debug("reading tuple element 0")
										v.V0, err = func(r interface {
											io.ByteReader
											io.Reader
										}) (string, error) {
											var x uint32
											var s uint8
											for i := 0; i < 5; i++ {
												slog.Debug("reading string length byte", "i", i)
												b, err := r.ReadByte()
												if err != nil {
													if i > 0 && err == io.EOF {
														err = io.ErrUnexpectedEOF
													}
													return "", fmt.Errorf("failed to read string length byte: %w", err)
												}
												if s == 28 && b > 0x0f {
													return "", errors.New("string length overflows a 32-bit integer")
												}
												if b < 0x80 {
													x = x | uint32(b)<<s
													if x == 0 {
														return "", nil
													}
													buf := make([]byte, x)
													slog.Debug("reading string bytes", "len", x)
													_, err = r.Read(buf)
													if err != nil {
														return "", fmt.Errorf("failed to read string bytes: %w", err)
													}
													if !utf8.Valid(buf) {
														return string(buf), errors.New("string is not valid UTF-8")
													}
													return string(buf), nil
												}
												x |= uint32(b&0x7f) << s
												s += 7
											}
											return "", errors.New("string length overflows a 32-bit integer")
										}(r)
										if err != nil {
											return nil, fmt.Errorf("failed to read tuple element 0: %w", err)
										}
										slog.Debug("reading tuple element 1")
										v.V1, err = func(r interface {
											io.ByteReader
											io.Reader
										}) (string, error) {
											var x uint32
											var s uint8
											for i := 0; i < 5; i++ {
												slog.Debug("reading string length byte", "i", i)
												b, err := r.ReadByte()
												if err != nil {
													if i > 0 && err == io.EOF {
														err = io.ErrUnexpectedEOF
													}
													return "", fmt.Errorf("failed to read string length byte: %w", err)
												}
												if s == 28 && b > 0x0f {
													return "", errors.New("string length overflows a 32-bit integer")
												}
												if b < 0x80 {
													x = x | uint32(b)<<s
													if x == 0 {
														return "", nil
													}
													buf := make([]byte, x)
													slog.Debug("reading string bytes", "len", x)
													_, err = r.Read(buf)
													if err != nil {
														return "", fmt.Errorf("failed to read string bytes: %w", err)
													}
													if !utf8.Valid(buf) {
														return string(buf), errors.New("string is not valid UTF-8")
													}
													return string(buf), nil
												}
												x |= uint32(b&0x7f) << s
												s += 7
											}
											return "", errors.New("string length overflows a 32-bit integer")
										}(r)
										if err != nil {
											return nil, fmt.Errorf("failed to read tuple element 1: %w", err)
										}
										return v, nil
									}(r, append(path, uint32(i))...)
									if err != nil {
										return nil, fmt.Errorf("failed to read list element %d: %w", i, err)
									}
								}
								return vs, nil
							}
							x |= uint32(b&0x7f) << s
							s += 7
						}
						return nil, errors.New("list length overflows a 32-bit integer")
					}(r, append(path, 3)...)
					if err != nil {
						return nil, fmt.Errorf("failed to read `annotations` field: %w", err)
					}
					return v, nil
				}(r, append(path, 2)...)
				if err != nil {
					return nil, fmt.Errorf("failed to read `metadata` field: %w", err)
				}
				slog.Debug("reading field", "name", "spec")
				v.Spec, err = func(r interface {
					io.ByteReader
					io.Reader
				}) (string, error) {
					var x uint32
					var s uint8
					for i := 0; i < 5; i++ {
						slog.Debug("reading string length byte", "i", i)
						b, err := r.ReadByte()
						if err != nil {
							if i > 0 && err == io.EOF {
								err = io.ErrUnexpectedEOF
							}
							return "", fmt.Errorf("failed to read string length byte: %w", err)
						}
						if s == 28 && b > 0x0f {
							return "", errors.New("string length overflows a 32-bit integer")
						}
						if b < 0x80 {
							x = x | uint32(b)<<s
							if x == 0 {
								return "", nil
							}
							buf := make([]byte, x)
							slog.Debug("reading string bytes", "len", x)
							_, err = r.Read(buf)
							if err != nil {
								return "", fmt.Errorf("failed to read string bytes: %w", err)
							}
							if !utf8.Valid(buf) {
								return string(buf), errors.New("string is not valid UTF-8")
							}
							return string(buf), nil
						}
						x |= uint32(b&0x7f) << s
						s += 7
					}
					return "", errors.New("string length overflows a 32-bit integer")
				}(r)
				if err != nil {
					return nil, fmt.Errorf("failed to read `spec` field: %w", err)
				}
				return v, nil
			}(r, []uint32{0}...)
			return (*KubernetesResource)(v), err
		}()

		if err != nil {
			slog.WarnContext(ctx, "failed to read parameter", "i", 0, "instance", "k8s:provider/request@0.1.0", "name", "delete", "err", err)
			if err := r.Close(); err != nil {
				slog.ErrorContext(ctx, "failed to close reader", "instance", "k8s:provider/request@0.1.0", "name", "delete", "err", err)
			}
			return
		}
		slog.DebugContext(ctx, "calling `k8s:provider/request@0.1.0.delete` handler")
		r0, err := h.Delete(ctx, p0)
		if cErr := r.Close(); cErr != nil {
			slog.ErrorContext(ctx, "failed to close reader", "instance", "k8s:provider/request@0.1.0", "name", "delete", "err", err)
		}
		if err != nil {
			slog.WarnContext(ctx, "failed to handle invocation", "instance", "k8s:provider/request@0.1.0", "name", "delete", "err", err)
			return
		}

		var buf bytes.Buffer
		writes := make(map[uint32]func(wrpc.IndexWriter) error, 1)

		write0, err := func(v *wrpc.Result[string, Error], w interface {
			io.ByteWriter
			io.Writer
		}) (func(wrpc.IndexWriter) error, error) {
			switch {
			case v.Ok == nil && v.Err == nil:
				return nil, errors.New("both result variants cannot be nil")
			case v.Ok != nil && v.Err != nil:
				return nil, errors.New("exactly one result variant must non-nil")

			case v.Ok != nil:
				slog.Debug("writing `result::ok` status byte")
				if err := w.WriteByte(0); err != nil {
					return nil, fmt.Errorf("failed to write `result::ok` status byte: %w", err)
				}
				slog.Debug("writing `result::ok` payload")
				write, err := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
					n := len(v)
					if n > math.MaxUint32 {
						return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
					}
					if err = func(v int, w io.Writer) error {
						b := make([]byte, binary.MaxVarintLen32)
						i := binary.PutUvarint(b, uint64(v))
						slog.Debug("writing string byte length", "len", n)
						_, err = w.Write(b[:i])
						return err
					}(n, w); err != nil {
						return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
					}
					slog.Debug("writing string bytes")
					_, err = w.Write([]byte(v))
					if err != nil {
						return fmt.Errorf("failed to write string bytes: %w", err)
					}
					return nil
				}(*v.Ok, w)
				if err != nil {
					return nil, fmt.Errorf("failed to write `result::ok` payload: %w", err)
				}
				if write != nil {
					return write, nil
				}
				return nil, nil
			default:
				slog.Debug("writing `result::err` status byte")
				if err := w.WriteByte(1); err != nil {
					return nil, fmt.Errorf("failed to write `result::err` status byte: %w", err)
				}
				slog.Debug("writing `result::err` payload")
				write, err := (v.Err).WriteToIndex(w)
				if err != nil {
					return nil, fmt.Errorf("failed to write `result::err` payload: %w", err)
				}
				if write != nil {
					return write, nil
				}
				return nil, nil
			}
		}(r0, &buf)
		if err != nil {
			slog.WarnContext(ctx, "failed to write result value", "i", 0, "instance", "k8s:provider/request@0.1.0", "name", "delete", "err", err)
			return
		}
		if write0 != nil {
			writes[0] = write0
		}
		slog.DebugContext(ctx, "transmitting `k8s:provider/request@0.1.0.delete` result")
		_, err = w.Write(buf.Bytes())
		if err != nil {
			slog.WarnContext(ctx, "failed to write result", "instance", "k8s:provider/request@0.1.0", "name", "delete", "err", err)
			return
		}
		if len(writes) > 0 {
			for index, write := range writes {
				_ = write
				switch index {
				case 0:
					w, err := w.Index(0)
					if err != nil {
						slog.ErrorContext(ctx, "failed to index result writer", "instance", "k8s:provider/request@0.1.0", "name", "delete", "err", err)
						return
					}
					write := write
					go func() {
						if err := write(w); err != nil {
							slog.WarnContext(ctx, "failed to write nested result value", "instance", "k8s:provider/request@0.1.0", "name", "delete", "err", err)
						}
					}()
				}
			}
		}
	})
	if err != nil {
		return nil, fmt.Errorf("failed to serve `k8s:provider/request@0.1.0.delete`: %w", err)
	}
	stops = append(stops, stop3)
	return stop, nil
}
